---
title: SpringBoot3基础特性
author: 柏竹
permalink: /backend/4s3321
date: 2023-06-07 00:00:00
categories: 
  - 后端
  - 框架
tags: 
  - SpringBoot
---

## SpringApplication

### 自定义Banner

Banner启动时会出现一个SpringBoot Logo , 该Logo配置是可进行修改的

**操作步骤 :** 

1. 配置文件新增 `spring.banner.location=classpath:banner.txt` 
2. 在资源根路径新建 `banner.txt` (内容自行编辑)

在线生成Banner : [https://www.bootschool.net/ascii](https://www.bootschool.net/ascii)

### 自定义Application

Application在运行前是需要加载本身配置的但我们可以自行修改配置

```java

@SpringBootApplication // 主程序配置
public class SpringBootFeaturesApplication {

    public static void main(String[] args) {
        //SpringApplication.run(SpringBootFeaturesApplication.class, args);

        SpringApplication application = new SpringApplication(SpringBootFeaturesApplication.class);

        // 关闭 Banner打印 , 等同于 spring.main.banner-mode=off 配置
        application.setBannerMode(Banner.Mode.OFF);

        application.run(args);
    }

}
```

::: tip

- 配置优先级 : 配置文件 > 程序运行配置

:::

## ProFiles

环境隔离的能力 , 实现快速切换 测试/生产 环境

**操作步骤 :** 

1. 标识环境 , 通过 `@Profile` 激活
2. 激活环境 , 指定环境生效

### 标识环境

通过 `@Profile`注解 进行标识环境 , 可以激活在 类/方法 上 

一般情况下采用 : dev(开发环境)/test(测试环境)/prod(生产环境)/default(默认环境)

```java
@Profile("dev")
@Component
public class Dog {
    
    @Profile("test")
    public void run(){
        System.out.println("Dog在跑");
    }
    
    @Override
    public String toString() {
        return "Dog 类加载完成";
    }
}
```

### 激活环境

实现切换环境的主要部分 , 指定激活环境的名称即可 , 支持多环境指定激活

**激活方式 :** 

- 配置文件激活 : `spring.profiles.active=dev,test`
- 命令行激活 : `java -jar xxx.jar --spring.profiles.active=dev` 
- 环境分组激活 : 组合使用如下
- 配置文件环境追加 : `spring.profiles.include`

**分组激活**

```properties
spring.profiles.active=hehe

spring.profiles.group.haha=dev
spring.profiles.group.hehe=dev,test
```

**环境追加**

支持数组区分追加

```properties
spring.profiles.include=dev
spring.profiles.include[0]=test
spring.profiles.include[1]=common
spring.profiles.include[2]=local
spring.profiles.include[3]=db
```

**实战场景**

生效的环境 = 激活的环境/默认环境 + 追加环境

一般情况下 : 

- 追加环境 : *mybatis* , *log*
- 激活环境 : *db* , *redis* 

```properties
spring.profiles.active=db,redis
# 追加
spring.profiles.include=prod
spring.profiles.group.prod[0]=mybatis
spring.profiles.group.prod[1]=log
```

### 配置环境

通过ProFile实现不同环境的配置文件生效

主配置文件 `application.properties` 

标识配置文件 `application-{profile标识}.properties` 

::: tip

profile标识的配置文件不能再次使用 , `spring.profiles.active` 激活其他配置文件

:::

主配置加载 标识配置文件

```properties
server.port=8088
spring.profiles.active=dev
```

标识配置文件 `application-dev.properties`

```properties
# 生效dev环境 相关的配置 (覆盖主配置 8088配置)
server.port=9000
```

::: tip

- 主配置 和 指定的配置文件 都会生效
- 主配置 和 指定的配置文件 配置项冲突 , 那么 主配置项会被覆盖 配置项

:::

## 外部化配置

上线应用的jar包 , 需要更改相关配置 , 可直接外部引用配置文件

一般情况下 : SpringBoot内部配置 + 外部文件配置 (外部覆盖内容 配置项)

### 配置优先级

SpringBoot配置的方式有很多种 , 如: Properties/Yaml/命令行/... , 他们的优先级都是有明确的划分

**优先级顺序 : (数值越大越高)**

1. 默认属性配置 (在启动前通过实例对象进行修改配置对象)
2. `@PropertySource`注解 加载指定配置文件 (写在 `@Configuration`注解 的类上才会生效)
3. 主配置文件
4. profile配置文件 (前提需要主配置 配置项激活)
5. `/config`目录下的 主配置文件
6. `/config`目录下的 profile配置文件 (前提需要激活)
7. jar包外的 主配置文件 (与jar包同级目录)
8. jar包外的 `/config`目录下的 主配置文件
9. jar包外的 `/config`目录下的 profile配置文件 (前提需要激活)
10. 命令行

> 还有很多配置方式 , 不过是比较冷门的使用方式 , 就略过了

**记忆规律**

- 命令行 > 所有
- 外包 > 内保
- config目录 > 根目录
- profile > application

优先级小的一方被覆盖相同配置项中的值

![image-20230608203847029](https://image.bozhu12.cc/myblog/SpringBoot/SpringBoot01.png)  

### 导入配置

外部引入的配置 通过 `spring.config.import` 导入额外配置

```properties
spring.config.import=classpath:/my.properties
```

::: tip

导入配置文件的优先级 与 `@PropertySource`注解 同等存在

:::

### 属性占位符

配置文件中 配置项的值是可以使用的 , 通过 `${name:default}`形式取出配置过的值

```properties
my=bohzu
# greeting=How are you? # 如果greeting配置项不存在 , 则 hello 替代
my.value=call Me ${my}!${greeting:hello!}
```

## 单元测试-JUnit5

单元测试相比大伙都比较熟悉 , 但 JUnit5 有个有趣的新特性参数化测试 , 将来会便利代码测试!

官方文档 : [https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations](https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations) 

### 参数化测试

利用 注解指定传入的数据 , 将其数据放入参数多次执行单元测试 , 减少代码测试运行次数

**涉及注解有 :** 

- `@ParameterizedTest`注解 : 标识参数化测试
- `@ValueSource`注解 : 指定来源参数 (支持八大基础类型)
- `@MethodSource`注解 : 读取的方法返回Stream作为参数填充 (读取的方法一定要是静态方法)
- `@NullSource`注解 : 表示为参数化测试提供一个null的入参
- `@EnumSource`注解 : 表示为参数化测试提供一个枚举入参
- `@CsvFileSource`注解 : 表示读取指定CSV文件内容作为参数化测试入参

```java
@ParameterizedTest
@ValueSource(strings = {"zs", "ls", "ww"})
void valueTest(String val) {
    System.out.println(val);
}

@ParameterizedTest
@MethodSource("method")
void methodTest(int val) {
    System.out.println(val);
}

static Stream<Integer> method() {
    return Stream.of(1,2,3,4);
}
```















