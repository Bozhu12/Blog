---
title: SpringBoot
author: 柏竹
permalink: /backend/40kn39
date: 2020-02-18 00:00:00
categories: 
  - 后端
  - 框架
tags: 
  - 
---



# SpringBoot

## 概述

Spring Boot 是 Spring 快速开发的脚手架，Spring Boot 大大优化了 Spring的 ==复杂配置== 和 ==依赖配置版本== 问题

**特点**

1. 独立运行 Spring项目
2. 内嵌 tomcat 和 jetty 容器 , 无需打包war文件
3. 简化 maven配置
4. 无 代码生成/xml配置
5. ...

## 首次应用

### Spring Boot无xml应用Web项目

模拟原生的Servlet搭建Web

> 该配置方式学习了解即可，并非针对学习！！

1. 创建 Maven无骨架项目 [IDEA创建Maven项目](https://blog.csdn.net/weixin_45963193/article/details/117839614?spm=1001.2014.3001.5502#t4) （无骨架Java项目）

2. `pom.xml` 引入 SpringBoot相关依赖

   ```xml
   <packaging>war</packaging>
   <!-- 集中定义依赖版本号 -->
   <properties>
       <spring.version>5.1.2.RELEASE</spring.version>
       <pagehelper.version>4.2.1</pagehelper.version>
   </properties>
   
   <dependencies>
   
       <!-- Spring -->
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-context</artifactId>
           <version>${spring.version}</version>
       </dependency>
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-beans</artifactId>
           <version>${spring.version}</version>
       </dependency>
       <dependency>
           <groupId>org.springframework</groupId>
           <artifactId>spring-webmvc</artifactId>
           <version>${spring.version}</version>
       </dependency>
       <dependency>
           <groupId>javax.servlet</groupId>
           <artifactId>javax.servlet-api</artifactId>
           <version>4.0.1</version>
           <scope>provided</scope>
       </dependency>
       <!-- jstl -->
       <dependency>
           <groupId>javax.servlet</groupId>
           <artifactId>jstl</artifactId>
           <version>1.2</version>
       </dependency>
   </dependencies>
   
   <build>
       <plugins>
           <plugin>
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-compiler-plugin</artifactId>
               <version>3.7.0</version>
               <configuration>
                   <source>1.8</source>
                   <target>1.8</target>
                   <encoding>UTF-8</encoding>
               </configuration>
           </plugin>
       </plugins>
   </build>
   ```

3. 建立 模拟web.xml配置 的Java程序类 `WebInit`类

   **web.xml文件配置** (比对示例的配置文件

   ```xml
   <servlet>
       <servlet-name>dispatcherServlet</servlet-name>
       <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
       <init-param>
           <param-name>contextConfigLocation</param-name>
           <param-value>classpath*:springmvc.xml</param-value>
       </init-param>
       <load-on-startup>1</load-on-startup>
   </servlet>
   <servlet-mapping>
       <servlet-name>dispatcherServlet</servlet-name>
       <url-pattern>/</url-pattern>
   </servlet-mapping>
   ```

   **Java程序配置** （应用代码

   ```java
   public class WebInit implements WebApplicationInitializer {
       // 初始化配置
       @Override
       public void onStartup(ServletContext servletContext) throws ServletException {
           // 指定 spring配置类
           AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
           context.register(SpringMVCConfig.class);
   
           // 添加Serlvet并指定映射
           ServletRegistration.Dynamic springmvc =
                   servletContext.addServlet("springmvc",new DispatcherServlet(context));
           springmvc.addMapping("/");
           springmvc.setLoadOnStartup(1);
       }
   }
   ```

   > SpringMVCConfig类 需要指定加载的 SpringMVC配置的类，在下面

4. 创建 SpringMVC配置类

   **web.xml文件配置** (比对示例的配置文件

   ```xml
   <mvc:annotation-driven />
   <context:component-scan base-package="com.sans"/>
   <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
   	<property name="prefix" value="/html/"/>
   	<property name="suffix" value=".html"/>
   </bean>
   ```

   **Java程序配置** （应用代码

   ```java
   @Configuration
   @ComponentScan("com.sans")
   @EnableWebMvc
   public class SpringMVCConfig implements WebMvcConfigurer {
   // 组件注解加载 xml：<mvc:default-servlet-handler/>
   @Override
   public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
       configurer.enable();
   }
   
   @Bean
   public ViewResolver viewResolver() {
       InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
       viewResolver.setPrefix("/html/");
       viewResolver.setSuffix(".html");
       return viewResolver;
   }
   ```

5. 创建 Controller 

   ```java
   package com.controller;
   
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   import javax.sql.DataSource;
   
   @Controller
   public class HelloController {
       @RequestMapping("/hello")
       public String hello() {
           return "test";
       }
   }
   ```

6. 在Web项目访问 html/test.html文件 访问即可

**项目结构**

```
  .
  |
  ├── src
  |    ├── main
  |	   |	├── java
  |	   |	|	  └── com
  |	   |    |   	   ├── controller
  |    |    |          |      └── HelloController.java
  |    |    |          └── config
  |    |    |                 ├── SpringMVCConfig.java
  |    |    |                 └── WebInit.java
  |	   |	└──	resources
  |	  test
  └── pom.xml
```

### Spring Boot启动器应用Web项目

1. 创建 Maven无骨架项目 [IDEA创建Maven项目](https://blog.csdn.net/weixin_45963193/article/details/117839614?spm=1001.2014.3001.5502#t4) （无骨架Java项目）

2. `pom.xml` 引入 SpringBoot相关依赖

   ```xml
   <project>
       ...
       <!--父工程坐标
           web相关应用无需配置再配置版本号(解决版本冲突问题)
       -->
       <parent>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-parent</artifactId>
           <version>2.0.0.RELEASE</version>
       </parent>
     
       <dependencies>
           <!--当中包含 tomcat、SpringMVC、...（有关web应用，自动配置）-->
           <dependency>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-web</artifactId>
           </dependency>
       </dependencies>
   ...
   </project>
   ```

3. 创建 `Application`启动器类 全限定名 com.Application 

   ```java
   package com;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   // @SpringBootApplication启动类
   @SpringBootApplication
   public class Application {
       
       public static void main(String[] args) {
           SpringApplication.run(Application.class , args);
       }
   
   }
   ```

4. 创建 `HelloController`控制器类 全限定名 com.controller.Application (为了方便看出构架结构)

   ```java
   package com.controller;
   
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   import javax.sql.DataSource;
   
   @RestController
   public class HelloController {
       
       @GetMapping("/hello")
       public String hello() {
           return "hello , Spring Boot...";
       }
       
   }
   ```

5. 启动类启用Main方法，再浏览器访问：http://localhost:8080/hello （页面返回有信息表示成功！）

   ![](http://sanscan12.gitee.io/blogimg/Content/Spring/SpringBoot01.png)

**项目结构**

```text
  .
  |
  ├── src
  |    ├── main
  |	   |	├── java
  |	   |	|	  └── com
  |	   |    |   	   ├── controller
  |    |    |          |        └── HelloController.java
  |	   |    | 		   └── Application.java
  |	   |	└──	resources
  |	  test
  └── pom.xml
```

## 数据配置

Spring Boot应用的是全注解配置（Java程序配置

**常用注解：** 

- `@Configuration` 
  声明在类上，作为配置类（代替xml文件）

- `@Bean` 
  声明在方法上，将方法返回值导入Bean容器（代替 标签）

- `@value` 
  属性注入（需要属性文件进行搭配应用）

- `@PropertySource` 
  引入读取外部属性文件

- [`@ConfigurationProperties`](#@自动注入配置) 
  引入读取外部属性文件，自动注入 成员变量（需要指定前缀 、Properties文件

- [`@EnableConfigurationProperties`](#@自动注入配置) 

  自动注入 @ConfigurationProperties类 

- `@RequestMapping` 
  负责URL路由映射 , 可以添加映射规则(请求类型/响应体/请求头/...) 
  
- [`@RestController`](#Controller配置) 
  响应的对象都会转换为JSON格式
  
- `@Component`
  把类对象实例化到 Bean容器 (类似于 

- `@PostConstruct` 方法
  在配置类 执行的构造函数 和自动注入 后执行初始化的方法(类似servlet的init()方法) 

- 

### Bean配置

通过 Spring Boot 还原 Spring配置连接池 的操作

**Spring 原配置**

```xml
<!-- 配置连接池 -->
<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
init-method="init" destroy-method="close">
	<property name="url" value="${jdbc.url}" />
	<property name="username" value="${jdbc.username}" />
	<property name="password" value="${jdbc.password}" />
</bean>
```

**Spring Boot配置** 

1. 在以上篇章 首次应用的代码 基础上进行更改

2. `pom.xml` 引入 Druid连接池依赖

   ```xml
   <dependency>
   	<groupId>com.alibaba</groupId>
   	<artifactId>druid</artifactId>
   	<version>1.1.10</version>
   </dependency>
   ```

3. 创建 `jdbc.properties`文件 到 `resources`资源中

   ```properties
   jdbc.driverClassName=com.mysql.jdbc.Driver
   jdbc.url=jdbc:mysql://127.0.0.1:3306/test
   jdbc.username=root
   jdbc.password=root
   ```

4. 创建 `JdbcConfig`配置类

   ```java
   package com.config;
   
   import com.alibaba.druid.pool.DruidDataSource;
   import org.springframework.beans.factory.annotation.Value;
   import org.springframework.boot.context.properties.EnableConfigurationProperties;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   import org.springframework.context.annotation.PropertySource;
   
   import javax.sql.DataSource;
   
   //配置类
   @Configuration
   //读取数据文件
   @PropertySource("classpath:jdbc.properties")
   public class JdbcConfig {
   
       /** 属性
        * 注入属性
        */
       @Value("${jdbc.driverClassName}")
       String driverClassName;
       @Value("${jdbc.url}")
       String url;
       @Value("${jdbc.username}")
       String username;
       @Value("${jdbc.password}")
       String password;
   
       /** 对象
        *  声明的Bean方法返回值会加入到Spring容器中
        *  说明：
        *      - 注解方法 Bean对象
        *      - 默认对象名id(Bean的ID) 与 方法名 一致
        *      - 自定义Bean对象名，可在注解 @Bean("自定义名称"),指定新对象
        */
       @Bean
       public DataSource dataSource() {
           DruidDataSource dataSource = new DruidDataSource();
           dataSource.setDriverClassName(driverClassName);
           dataSource.setUrl(url);
           dataSource.setUsername(username);
           dataSource.setPassword(password);
           return dataSource;
       }
   
   }
   ```

5. 在 `HelloController`控制类 自动注入测试

   ```java
   package com.controller;
   
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.web.bind.annotation.GetMapping;
   import org.springframework.web.bind.annotation.RestController;
   
   import javax.sql.DataSource;
   
   @RestController
   public class HelloController {
       
       // 该注解自动匹配名称进行指定注入
       @Autowired
       private DataSource dataSource;
   
       @GetMapping("/hello")
       public String hello() {
           return "hello , Spring Boot..." + dataSource;
       }
       
   }
   ```

6. 启用Main方法调试测试。可利用断点进行查看配置连接池的参数传递情况 

### Controller配置

Controller配置中 Spring提供有以下两种注解进行应用 

- `@Controller` 请求包含有 页面和数据
- `@RestController` 请求只有 数据

> 一般情况下使用的 `@RestController` 居多 , 前后端分离嘛 . `@Controller` 则需要搭配模板引擎进行应用

**参数传递**
直接上代码 , 详细了解进入 SpringMVC参数传递篇

```java
@RestController
public class ParamsController {

    // http://localhost:8080/getTest1
    @RequestMapping(value = "getTest1", method = RequestMethod.GET)
    public String getTest1() {
        return "GET请求1";
    }

    // http://localhost:8080/getTest2?nickname=zs&phone=123
    @RequestMapping(value = "getTest2", method = RequestMethod.GET)
    public String getTest2(String nickname, String phone) {
        System.out.println("nickname = " + nickname);
        System.out.println("phone = " + phone);
        return "GET请求2";
    }

    // http://localhost:8080/getTest3?name=zs
    @RequestMapping(value = "getTest3", method = RequestMethod.GET)
    public String getTest3(@RequestParam("name") String nickname) {
        System.out.println("nickname = " + nickname);
        return "GET请求3";
    }

    // http://localhost:8080/postTest1
    @RequestMapping(value = "/postTest1", method = RequestMethod.POST)
    public String postTest1() {
        return "POST请求1";
    }

    // http://localhost:8080/postTest2
    /*
    * application/x-www-form-urlencoded : {
    *   username:zs,
    *   password:123
    * }
     * */
    @RequestMapping(value = "/postTest2", method = RequestMethod.POST)
    public String postTest2(String username, String password) {
        System.out.println("username = " + username);
        System.out.println("password = " + password);
        return "POST请求2";
    }

    // http://localhost:8080/postTest3
    /*
     * application/x-www-form-urlencoded : {
     *   username:zs,
     *   password:123
     * }
     * */
    @RequestMapping(value = "/postTest3", method = RequestMethod.POST)
    public String postTest3(MyUser user) {
        System.out.println(user);
        return "POST请求3";
    }

    // http://localhost:8080/postTest4
    /*
       application/json : {
         "username":"zs",
         "password":"123"
       }
     */
    @RequestMapping(value = "/postTest4", method = RequestMethod.POST)
    public String postTest4(@RequestBody MyUser user) {
        System.out.println(user);
        return "POST请求4";
    }

    // http://localhost:8080/test/xxx...
    @GetMapping("/test/**")
    public String test() {
        return "通配符请求";
    }
}
```

**通配符**

- `*` : 任意单词
- `**` : 任意路径
- `?` : 任意单个字符

> 通常使用的 `*` 较多 , 比如指定未知文件名的文件等等...

### 自动注入配置

SpringBoot注解配置 正是优化 Spring注解配置 的存在。虽然以上spring注解配置可行，但配置依旧有些许繁琐。

#### @ConfigurationProperties

该注解有两种实现方式 **类/方法** 上

#### 定义在类上

将 **类的成员变量** 与 **配置文件key值** 进行匹配赋予值，赋予值的前提需要指定 配置文件的前缀字符串`prefix` 

**例如：**

```properties
jdbc.driver.username=root
jdbc.driver.password=root
```

```java
@ConfigurationProperties(prefix = "jdbc.driver")
public class JdbcProperties {
    private String driverClassName;
    private String url;
    private String username;
    private String password;
    // settre/gettre 方法省略 （一定一定不能少写
}
```

> 应用需要搭配 @EnableConfigurationProperties注解 进行使用

#### 定义在方法上

Bean方法 返回直接声明使用，这一过程无需`@EnableConfigurationProperties`注解 进行读取类对象应用

> **应用前提：** 注入的对象必须有 set方法

```java
// 声明要注入属性前缀，SpringBoot会自动把相关属性通过set方法进行注入到dataSource中
// 应用前提删除 JdbcProperties属性读取类 已经使用 属性的前缀值 进行读取
@Bean
@ConfigurationProperties (prefix = "jdbc")
public DataSource dataSource() {
    return new DruidDataSource();
}
```

#### @EnableConfigurationProperties

用于声明指定获取存储参数的对象，参数 `value` 其值为 指定某个存储参数的类

自动注入方式：

1. @Autowired注入
2. 声明有@Bean的方法参数注入

**以下示例以连接池的配置进行测试** 

1. 创建 `JdbcProperties`属性读取类 ，全限定名 com.config.JdbcProperties

   ```java
   package com.config;
   
   import org.springframework.boot.context.properties.ConfigurationProperties;
   
   /** 属性读取类
    * @ConfigurationProperties （属性配置）
    *      prefix = "jdbc" , 配置数据的前缀为jdbc的值 (它只会读取前缀为jdbc的值)
    */
   @ConfigurationProperties(prefix = "jdbc")
   public class JdbcProperties {
   
       private String driverClassName;
       private String username;
       private String password;
       private String url;
       
       // set 和 get 
       ...
   }
   ```

2. `JdbcConfig`配置类 ，全限定名 com.config.JdbcConfig 

   ```java
   package com.config;
   
   import com.alibaba.druid.pool.DruidDataSource;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.context.properties.EnableConfigurationProperties;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   import javax.sql.DataSource;
   
   // 定义 配置类
   @Configuration
   // 定义 加载配置文件
   @PropertySource("classpath:jdbc.properties")
   // 定义 启动加载实体
   @EnableConfigurationProperties(JdbcProperties.class)
   public class JdbcConfig {
   
       /** 方式1 （成员变量注入
        *  步骤：
        *    1. 加载配置文件 @PropertySource("classpath:jdbc.properties")
        *    2. 成员变量赋予值 @Value()
        */
       @Value("${jdbc.driverClassName}")
       private String driverClassName;
       @Value("${jdbc.url}")
       private String url;
       @Value("${jdbc.username}")
       private String username;
       @Value("${jdbc.password}")
       private String password;
   
       @Bean
       public DataSource dataSource01() {
           DruidDataSource dataSource = new DruidDataSource();
           dataSource.setDriverClassName(driverClassName);
           dataSource.setUrl(url);
           dataSource.setUsername(username);
           dataSource.setPassword(password);
           return dataSource;
       }
   
       /** 方式2 （实体对象注入
        *  步骤：
        *    1. 创建承载的实体 JdbcProperties对应前缀属性指定填充。通过 @ConfigurationProperties注解实现参数填充
        *    2. 加载配置文件 @PropertySource("classpath:jdbc.properties")
        *    3. 启动指定实体类的自动注入 @EnableConfigurationProperties(JdbcProperties.class)
        *    4. 承载实体对象自动注入 @Autowired
        */
       @Autowired
       private JdbcProperties jdbcProperties;
   
       @Bean
       public DataSource dataSource02() {
           DruidDataSource dataSource = new DruidDataSource();
           dataSource.setDriverClassName(jdbcProperties.getDriverClassName());
           dataSource.setUrl(jdbcProperties.getUrl());
           dataSource.setUsername(jdbcProperties.getUsername());
           dataSource.setPassword(jdbcProperties.getPassword());
           return dataSource;
       }
   
       /** 方式3 （方法参数注入
        *  步骤：
        *    1. 创建承载的实体 JdbcProperties对应前缀属性指定填充。通过 @ConfigurationProperties注解实现参数填充
        *    2. 加载配置文件 @PropertySource("classpath:jdbc.properties")
        *    3. 注解加载配置文件 @EnableConfigurationProperties(JdbcProperties.class)
        *    4. 方法参数直接应用
        */
       @Bean
       public DataSource dataSource03(JdbcProperties jdbc) {
           DruidDataSource dataSource = new DruidDataSource();
           dataSource.setDriverClassName(jdbc.getDriverClassName());
           dataSource.setUrl(jdbc.getUrl());
           dataSource.setUsername(jdbc.getUsername());
           dataSource.setPassword(jdbc.getPassword());
           return dataSource;
       }
       
       /** 方式4 （@ConfigurationProperties注入
        *  创建承载的实体 JdbcProperties对应前缀属性指定填充。通过 @ConfigurationProperties注解实现 数据直接填充
        */
       @Bean
       @ConfigurationProperties(prefix = "jdbc.driver")
       public DataSource dataSource04() {
           return new DruidDataSource();
       }
   
   }
   ```

3. Controller层。自动注入，断点测试

   ```java
   @RestController
   public class HelloContoller {
   
       // Bean配置注入
       @Autowired
       private DataSource dataSource01;
       // @EnableConfigurationProperties 注解注入
       @Autowired
       private DataSource dataSource02;
       // @EnableConfigurationProperties 方法参数注入
       @Autowired
       private DataSource dataSource03;
       // @ConfigurationProperties注入
       @Autowired
       private DataSource dataSource04;
   
       /**
        *  运行时 断点查看 成员变量
        */
       @GetMapping("/hello")
       public String hello() {
           return "hello";
       }
   
   }
   ```

4. 启用Main方法调试测试



### 配置文件

SpringBoot 在启动时会将 resources 目录下的 `application.properties` 或 `apllication.yml` 文件 作为其默认配置文件（它们可以包含多个文件）

**.properties 和 .yml 的区别**

- 配置结构：.properties 线性结构 ；.yml 树状结构
- 分割方式：.properties 以 `.` 进行分割；.yml 以 `:` 进行分割

.properties配置文件

```properties
# properties格式
environments.dev.url=http://dev.bar.com
environments.dev.name=Developer Setup
environments.prod.url=http://foo.bar.com
environments.prod.name=My Cool App
my.servers[0]=dev.bar.com
my.servers[1]=foo.bar.com
```

.yml配置文件

```yaml
# YAML格式
environments:
	dev:
		url: http://dev.bar.com
		name: Developer Setup
	prod:
		url: http://foo.bar.com
		name: My Cool App
my:
	servers:
		- dev.bar.com
		- foo.bar.com
```

**优先级**

目录的配置文件都会被加载，且顺序就是它们的优先级依次降低

1. file：`./config/`
2. file：`./config/*/`
3. file：`./`
4. classpath：`/config/`
5. classpath：`/`

相同位置的 `application.properties` 和 `application.yml` ，而`application.properties` 更优先加载 

> **file：** 指当前项目根目录
>
> **classpath：**指当前项目的类路径，即 resources 目录

多个配置文件存在的时候且它们有相同的配置内容情况下，SpringBoot会根据优先级进行覆盖低级的配置，形成互补配置：

- 存在相同配置内容，高级覆盖低级的配置内容
- 存在不同的配置内容，所有配置内容都读取

**示例：** 

在以上的基础进行测试

![](http://sanscan12.gitee.io/blogimg/Content/Spring/SpringBoot03.png)

`application.yml`文件

```yaml
# 类路径下的 config 目录下
# 端口号为8090
# 上下文路径为 /test2
server:
    port: 8090
    servlet:
        context-path: /test2
#...
```

`application.properties`文件

```properties
server.port=8080
server.servlet.path=/test1
#...
```

启动 SpringBoot，控制信息：

![](http://sanscan12.gitee.io/blogimg/Content/Spring/SpringBoot04.png)

通过浏览器访问测试

![](http://sanscan12.gitee.io/blogimg/Content/Spring/SpringBoot05.png)

> 出现以上字样，因本地 test1、test2没有对应的资源

### Session集群共享

SpringBoot默认情况下存Session到本机中 , 多台服务器不会共享Session 

**解决方案 : **

Spring-Session 和 Redis 整合

1. 引入 `redis` 和 `spring-session redis` jar包
2. 配好 `redis`连接 和 `Session`存储方式

```yaml
# redis 配置
spring:
    redis:
        port: 6379
        host: localhost
        database: 0
    session:
    	store-type: redis
```

> Session的读取会通过Redis进行的

### 计划任务

`@EnableScheduling` 在配置类上使用，开启计划任务的支持

1. `@EnableScheduling`定义指定启动类 application上
2. `@Scheduled`定义指定方法 预定执行(运行频率/运行周期等配置...)
3. 运行即可

### 热部署

在实际开发中会频繁的修改后台类文件 , 而且每次修改都需要重新进行编译运行 , 因此非常的麻烦 . 

Spring Boot 提供了 devtools组件 , 热部署正是解决了该问题 , devtools会监听 , classpath下的文件变动 , 触发 Restart类加载器加载该类 , 实现文件和配置热部署功能

**热部署应用** 

1. **pon.xml**

   ```xml
   <!-- 热部署 -->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-devtools</artifactId>
       <optional>true</optional>
   </dependency>
   ```

2. **application.properties**

   ```properties
   # 热部署
   # 启动 热部署
   spring.devtools.restart.enabled=true
   # 重启目录
   spring.devtools.restart.additional-paths=src/main/java
   # classpath目录 修改修改不重启
   spring.devtools.restart.exclude=static/**
   ```

3. **设置启动自动构建项目**
   设置 -> 搜索Conpile(编辑器) -> 勾选Build project automatically(启动自动构建项目)

4. **设置运行时执行刷新**
   ==Ctrl+Shift+Alt+/== -> 进入Registry(注册表) -> 启动compiler.automake.allow.when.app.running(运行时执行)

   **PS : 如果 4步骤没有该选项 , 则操作一下步骤 : 设置 -> Advansed Settings(高级设置) -> 勾选Allow auto-make(运行时执行)** 

> 做完以上配置 , 可以在类中边修改边测试代码啦

### 日志

SpringBoot 选用 SLF4j 和 logback (大厂建议: SLF4j)

SLF4j官方文档 : 

- https://springdoc.cn/spring-boot/features#features.logging
- https://www.slf4j.org/manual.html
- https://www.slf4j.org/apidocs/index.html

**简单日志示例 :** 

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HelloWorld {

  public static void main(String[] args) {
    Logger logger = LoggerFactory.getLogger(HelloWorld.class);
    logger.info("Hello World");
  }
}
```

#### 日志级别

trace < debug < info < warn < error

info后面的才可打印至控制台

常用 trace/debug/info 三种日志输出

```java
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class LogingApplicationTests {

    // 记录器
    Logger logger = LoggerFactory.getLogger(getClass());

    @Test
    public void contextLoads(){
        // 日志级别
        // trace < debug < info < warn < error
        logger.trace("trace日志");
        logger.debug("debug日志");
        logger.info("info日志");
        logger.warn("warn日志");
        logger.error("error日志");
    }

}
```

#### 日志配置

只需在 `applicaton.properties`文件 配置即可

| 配置K                       | 值V               | 说明                                  |
| --------------------------- | ----------------- | ------------------------------------- |
| `logging.level.com.atguigu` | (Boolean) true    | 控制台打印级别限制解除                |
| `logging.file.name`         | (String) my.log   | 输出日志到 指定文件(my.log)           |
| `logging.file.path`         | (String) /var/log | 输出日志到 指定目录的指定文件(my.log) |
| `logging.pattern.console`   | (String)          | 在控制台输出日志格式                  |
| `logging.pattern.file`      | (String)          | 指定文件中日志输出格式                |

> **注意 :** 
>
> - 如果定义 loggin.path路径没有指定文件 , 则会在默认系统根路生成日志文件
> - 默认格式 : **日期 - 时间 - 日志级别 - 线程id - 线程名称 - 全类名 - 消息**

**配置日志格式 :** 

| 日志格式    | 说明                    |
| ----------- | ----------------------- |
| %d          | 日期时间                |
| %thread     | 线程名                  |
| %-5level    | 级别显示字符宽度        |
| %logger{50} | 日志名最长50 , 否则分割 |
| %msg        | 日志消息                |
| %n          | 换行                    |

全格式 : ==%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n== 

个人应用格式 : ==%d{MM-dd HH:mm} %-5level %msg%n== 

  

## 框架整合

SpringBoot 抛弃了传统 xml 配置文件，以Java程序的形式进行配置。因此其他配置整合需要应用说明

### SpringMVC 整合

SpringBoot 对 SpringMVC 的一些自动配置可以满足大部分需求，但也可以自定义配置类 并实现`org.springframework.web.servlet.config.annotation.WebMvcConfigurer`接口 进行配置

**接口提供方法**

| 返回   | 方法                                                      | 说明                            |
| ------ | --------------------------------------------------------- | ------------------------------- |
| `void` | ==addInterceptors(InterceptorRegistry registry)==         | 添加 拦截器，对请求进行拦截处理 |
| `void` | ==addResourceHandlers(ResourceHandlerRegistry registry)== | 添加 或 修改静态资源            |
| `void` | ==addViewControllers(ViewControllerRegistry registry)==   | 无业务逻辑跳转（虚实映射重定向  |
| `void` | ==addCorsMappings(CorsRegistry registry)==                | 解决跨域问题                    |

以下 SpringMVC配置问题 主要解决：

- [**修改端口**](#修改端口) 
- [**静态资源加载**](#静态资源加载) 
- [**拦截器配置**](#拦截器配置)  
- [**虚实映射重定向**](#虚实映射重定向) 
- [**跨域**](#跨域) 

#### 修改端口

在SpringBoot的 全局属性(application.properties文件) 进行以下配置端口：

```properties
# 映射端口
server.port=80 
```

#### 静态资源加载

Spring Boot 中 `org.springframework.boot.autoconfigure.web.ResourceProperties`类 ，已经定义了静态资源的默认路径 ：（以下路径创建对应的目录即可直接访问

```java
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {
			"classpath:/META-INF/resources/", "classpath:/resources/",
			"classpath:/static/", "classpath:/public/" };
```

- ==classpath:/META-INF/resources/== 
- ==classpath:/resources/== 
- ==classpath:/static/== 
- ==classpath:/public== 

> `classpath:/` 指定的目录是指 缓存中加载的类路径classes

> 以上目录可以在项目中直接访问到指定根目录。如果自定义的资源路径则需要指定确定路径，例如：
>
> 项目默认的路径 : 测试访问 static/1.jpg
> ==localhost:8080/1.jpg==

**自定义静态资源路径**

1. **重写方法映射**
   在SpringMVC的配置类中 重写 `addResourceHandlers()`方法 以下代码：

   ```java
   @Override
   public void addResourceHandlers(ResourceHandlerRegistry registry) {
       // 类似于 SpringMVC配置
       // <mvc:resources mapping="/test/**" location="/test/"/>
    	registry.addResourceHandler("/test/**").addResourceLocations("classpath:/test/");
   }
   ```

   > 如果指定实体本机文件则：
   > ==registry.addResourceHandler("/pic/**").addResourceLocations("file:"+"D:/uploadFiles/");==

2. **修改配置文件**
   修改 application.properties更改规则

   ```properties
   # 过滤规则
   spring.mvc.static-path-pattern=/static/**
   # 静态资源位置
   spring.web.resources.static-locations=classpath:/static/
   ```

   > 以上是默认配置 , 可手写覆盖 , 覆盖后原有的会失效

#### 文件上传

表单默认应用 enctype="application/x-www-form-urlencoded" , 需要改成 enctype="multipart/form-data" 进行上传文件

**修改默认大小限制**

默认每个1M , 配置修改

```properties
# 单个文件最大
spring.servlet.multipart.max-file-size=10MB
# 单次请求最大
spring.servlet.multipart.max-request-size=10M
```

**应用**

```java
@RestController
public class FileUploadController {
    @PostMapping("/upload")
    public String up(String nickname, MultipartFile photo , HttpServletRequest request) throws IOException {
        System.out.println("nickname = " + nickname);

        // 图片信息
        System.out.println("图片原始名称: "+photo.getOriginalFilename());
        System.out.println("图片类型: "+photo.getContentType());

        String path = request.getServletContext().getRealPath("/upload/");
        System.out.println("path = " + path);

        // 存储
        saveFile(photo,path);
        return "上传完毕";
    }

    // 存储
    private void saveFile(MultipartFile photo, String path) throws IOException {

        File dir = new File(path);
        // 目录空则创建
        if (!dir.exists()) {
            dir.mkdir();
        }
        File file = new File(path + photo.getOriginalFilename());
        photo.transferTo(file);
    }
}
```

#### 拦截器

拦截器需要自行配置 。 [SpringMVC拦截器类配置了解](https://blog.csdn.net/weixin_45963193/article/details/118798080?spm=1001.2014.3001.5501) 

Spring Boot 定义了 HandlerInterceptor接口 , 该接口实现了自定义拦截器的功能 , 可以重写以下三个过程方法进行 :

1. **请求前** ==preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)== 

   **参数**：`handler` 被拦截的控制器对象（MyController）
   **返回**：是否允许放行，false拦截

2. **请求处理后** ==postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)== 

   **参数**：`handler` 被拦截的控制器对象 ；`modelAndView` 控制器方法的返回值

3. **请求最后** ==afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)== 
   **参数**：`handler` 被拦截的控制器对象 ；`ex` 控制器方法异常

![](http://sanscan12.gitee.io/blogimg/Content/Spring/SpringBoot06.png)

**应用**

1. 创建 MyInterceptor自定义拦截器类 （模拟日志形式进行输出）

   ```java
   public class MyInterceptor implements HandlerInterceptor {
   
       private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);
       
       @Override
       public boolean preHandle(HttpServletRequest request , HttpServletResponse response , Object handler) {
           logger.debug("处理器执行前执行!");
           return true;
       }
       
       @Override
       public void postHandle(HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView) throws Exception {
           logger.debug("处理器执行后执行!");
       }
       
       @Override
       public void afterCompletion(HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex) throws Exception {
           logger.debug("跳转后执行！");
       }
       
   }
   ```
   
2. 在SpringMVC的配置类中 重写 `addInterceptors`方法 添加自定义拦截器
   应用前提需要将 自定义拦截类 添加到Spring容器中进行指定注入

   ```java
   @Configuration
   public class SpringMVCConfig implements WebMvcConfigurer {
   	@Override
   	public void addInterceptors(InterceptorRegistry registry) {
   		// 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 (不加则拦截所有)
   		registry.addInterceptor(new MyInterceptor()).addPathPatterns("/user/**");
   	}
   }
   ```
   
3. 在 全局属性(application.properties文件) 进行添加属性（此时在控制器是看不到日志的输出）
   因 记录打印 级别 : `debug` ，日志打印 级别 ：`info` 

   ```properties
   # 设置 com.*包 的日志级别为debug 
   logging.level.com.*=debug
   ```

4. 启用Main方法调试测试，浏览器访问有效路径，看见控制台打印日志信息表示完成！！！

#### 虚实映射重定向

主要意图是把 访问的URI 转换至 自定义URI ，达到重定向效果
实现需要在 SpringMVC的配置类中 重写 `addViewControllers()`方法 以下代码：

```java
@Override
public void addViewControllers(ViewControllerRegistry registry) {
    registry.addViewController("/").setViewName("login.html");
    registry.setOrder(Ordered.HIGHEST_PRECEDENCE);
}
```

> 首次访问重定向值登录页面，且设置最高优先级

#### 跨域

CORS 是种 跨域资源共享的技术标准 , 为了更好的解决前端跨域请求 , CORS请求分为 简单请求 / 非简单请求 分别对跨域提供支持

**跨域 :**  当一个请求 url 的 **协议/域名/端口** 三者任意一个 与 当前页面url不同 称为 跨域

#### 简单请求

**请求方法 :** `GET` / `POST` / `HEAD`
**未自定义的请求头 :** 
`Accept` / `Accept-Language` / `Content--Language` / `Last-Event--lD` / 
`Content-Type`
**Content-Type 的值只有以下三种 :** 
`text/plain` , `multipart/form-data` , `application/x-www-form-urlencode`

**前端发出请求时 :** 
CORS的策略在请求头新增了个 `Origin`字段(url) , 用于告诉服务器来自哪里

**后端收到请求后 :** 

可以根据 `Origin`字段 判断是否允许请求访问 , 如果允许 会在HTTP头信息添加 `Access-Control-Allow-Origin`字段(应用端口)

#### 非简单请求

非简单请求时 浏览器会在真实请求发出前增加一次OPTION请求 称为预检请求

预检请求将真实请求的信息 , 包括请求方法/自定义头字段/源信息 添加到HTTP头信息字段中 , 询问服务器是否允许这样的操作

**前端发出请求 :** 

```properties
OPTIONS /test HTTP/1.1
Origin: http://www.test.com
Access-Control-Request-Method: GET
# 请求的自定义头字段
Access-Control-Request-Headers: X-Custom-Header
Host: www.test.com
```

**后端收到请求后 :** 
会对 `Origin` / `Access-Control-Request-Method` / `Access-Control-Request-Headers` 字段进行验证 , 后端请求允许通过后会返回

```properties
# 真实请求 请求允许 来源url/方法/头信息
Access-Control-Allow-Origin: http://www.test.com
Access-Control-Allow-Methods: GET,POST,PUT,DELETE
Access-Control-Allow-Headers: X-Custom-Header
# 允许 用户 发送/处理 cookie
Access-Control-Allow-Credentials: true
# 允许 请求有效期 毫秒
Access-Control-Max-Age: 1728000
```

#### SpringBoot解决方案

解决跨域问题需要在 SpringMVC的配置类中 重写 `addCorsMappings()`方法 以下代码：

**springboot 2.4.0版本前 :** 

 ```java
 @Override
 public void addCorsMappings(CorsRegistry registry) {
     // 允许访问的路径
         registry.addMapping("/**")
                 // 是否发送 cookie
                 .allowCredentials(true)
                 // 允许 跨域访问的源
                 .allowedOrigins("*")
                 // 允许 接收的请求类型
                 .allowedMethods("POST","GET")
                 // 允许 头部设置
                 .allowedHeaders("*")
                 // 允许 有效期
                 .maxAge(1800);
 }
 ```

**springboot 2.4.0版本后 :**  
方法名更变为 : `allowedOrigins` => `allowedOriginPatterns` 

```java
@Override
public void addCorsMappings(CorsRegistry registry) {
    // 允许访问的路径
    registry.addMapping("/**")
            // 是否发送 cookie
            .allowCredentials(true)
            // 允许 跨域访问的源
            .allowedOriginPatterns("*")
            // 允许 接收的请求类型
            .allowedMethods("POST","GET")
            // 允许 头部设置
            .allowedHeaders("*")
            // 允许 有效期
            .maxAge(1800);
}
```

**方案2 :** 
在启动器类加上注解 `@CrossOrigin` . 也可实现跨域功能 (PS注意版本问题)

#### url图片

```java
@Controller
@RequestMapping(value = "/image")
public class ImageController {
    @RequestMapping(value = "/get",produces = MediaType.IMAGE_JPEG_VALUE)
    @ResponseBody
    public byte[] getImage() throws IOException {
        File file = new File("D:/test.jpg");
        FileInputStream inputStream = new FileInputStream(file);
        byte[] bytes = new byte[inputStream.available()];
        inputStream.read(bytes, 0, inputStream.available());
        return bytes;
    }
}
```

### JDBC 整合

SpringBoot 中默认自动配置有 HikariCP连接池（HikariCP连接池是目前最快的连接池）

1. 引入依赖 `pom.xml`文件 

   ```xml
   <!--jdbc-->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-jdbc</artifactId>
   </dependency>
   <!--测试-->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-test</artifactId>
   </dependency>
   <!--mysql-->
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.46</version>
   </dependency>
   ```

   > 连接数据库 mysql的依赖 ，需要添加依赖 和 自行配置版本号。因 该依赖并非是 SpringBoot的相关组件  

2. 在SpringBoot的 全局属性(application.properties文件) 添加参数

   ```properties
   # 连接四大参数
   spring.datasource.url=jdbc:mysql://localhost:3306/库名
   spring.datasource.username=root
   spring.datasource.password=root
   # 可省略，SpringBoot自动推断
   #spring.datasource.driverClassName=com.mysql.jdbc.Driver
   #spring.datasource.hikari.idle-timeout=60000
   #spring.datasource.hikari.maximum-pool-size=30
   #spring.datasource.hikari.minimum-idle=10
   ```

3. 创建 User实体类 （指定库中的表列属性信息）

   ```java
   public class User implements Serializable {
       
       private Long id;
       // 用户名
       private String userName;
       // 密码
       private String password;
       // 姓名
       private String name;
       // 年龄
       private Integer age;
       // 性别，1男性，2女性
       private Integer sex;
       // 出生日期
       private Date birthday;
       
       //省略 get 、 set 和 toString
   }
   ```

   > 表列名 和 类属性名 一致，在这一说法的前提它们支持 驼峰命名 和 下划线命名
   > 如： (库列名) user_name -> (类属性名)userName

4. 创建 JdbcDao操作类

   ```java
   @Repository
   public class JdbcDao {
       
       @Autowired
       private JdbcTemplate jdbcTemplate;
       
       public List<User> findAll() {
           // BeanPropertyRowMapper : 可将同名的字段赋值给属性 （支持驼峰、下划线）
           return jdbcTemplate.query("select * from tb_user" ,
                   new BeanPropertyRowMapper<>(User.class));
       }
       
   }
   ```

5. 测试

   ```java
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class JdbcDaoTest extends TestCase {
       
       @Autowired
       private JdbcDao jdbcDao;
       
       @Test
       public void testFindAll() {
           System.out.println("jdbcDao : " + jdbcDao);
           
           for (User user : jdbcDao.findAll()) {
               System.out.println(user);
           }
       }
       
   }
   ```

### MyBatis 整合

1. 引入依赖 `pom.xml`文件 

   ```xml
   <!--mybatis -->
   <dependency>
       <groupId>org.mybatis.spring.boot</groupId>
       <artifactId>mybatis-spring-boot-starter</artifactId>
       <version>1.3.2</version>
   </dependency>
   <!--测试-->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-test</artifactId>
   </dependency>
   ```

2. 在SpringBoot的 全局属性(application.properties文件) 添加参数

   ```properties
   # mybatis 别名扫描
   mybatis.type-aliases-package=com.pojo
   # mapper.xml文件位置 (使用在有映射的前提)
   mybatis.mapper-locations=classpath:mappers/*.xml
   ```

3. 创建 User实体类 （指定库中的表列属性信息）

   ```java
   package com.pojo;
   
   import javax.persistence.*;
   import java.io.Serializable;
   import java.util.Date;
   
   public class User implements Serializable {
       
       private Long id;
       // 用户名
       private String userName;
       // 密码
       private String password;
       // 姓名
       private String name;
       // 年龄
       private Integer age;
       // 性别，1男性，2女性
       private Integer sex;
       // 出生日期
       private Date birthday;
       
       //省略 get 、 set 和 toString
   }
   ```

   > 表列名 和 类属性名 一致，MyBatis不支持 驼峰、下划线 命名方式

4. 创建 `UserMapping`接口 ，全限定名 com.mapping.UserMapping

   ```java
   package com.dao;
   
   import com.pojo.User;
   import java.util.List;
   
   public interface UserMapping {
       List<User> findAll();
   }
   ```

5. 创建 `UserMapping.xml`映射文件

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="com.mapping.UserMapping">
   
       <select id="findAll" resultType="user">
           select * from tb_user
       </select>
   
   </mapper>
   ```

6. Mapper映射加载 。加载方式有两种

   1. 使用 @Mapping注解
      在 `UserMapping`接口 添加 `@Mapper`注解 进行识别

      ```java
      @Mapper
      public interface UserMapper {
          ....
      }
      ```

   2. 使用 @MapperScan注解 扫描的包
      在 `@SpringBootApplication`注解下的启动类，添加@MapperScan注解 value参数为 扫描的包路径

      ```java
      package com;
      import org.mybatis.spring.annotation.MapperScan;
      import org.springframework.boot.SpringApplication;
      import org.springframework.boot.autoconfigure.SpringBootApplication;
      
      // 启动类
      @SpringBootApplication
      @MapperScan("com.mapping")
      public class Application {
          public static void main(String[] args) {
              SpringApplication.run(Application.class , args);
          }
      }
      ```

7. 测试

   ```java
   package com.dao;
   
   import junit.framework.TestCase;
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class UserDaoTest extends TestCase {
       
       @Autowired
       private UserMapping userMapping;
       
       @Test
       public void findAll() {
            for (User user : userMapping.findAll()) {
               System.out.println(user);
           }
       }
   }
   ```

### tk-MyBatis 整合

由于MyBatis的使用会出现一些功能上的问题，和大量的xml文件。当库表结构进行改动，则实体和xml文件都需要重新更改。因此为了避免以上情况 ，应用 tk-MyBatis框架

**使用前注意事项：**

- tk-MyBatis依赖引入 后就无需再引入MyBatis依赖
- 支持 驼峰、下划线 命名方式，需要手动纠正
- 实体类中 主键一定要映射 `@GeneratedValue`注解 映射主键策略（该字段自增、...等其他索引约束）
- 类与表不匹配的情况，使用 jpa注解 纠正（名相同无需添加注解）
  1. 类名 ≠ 表名 ，在类上添加 `@Table`注解 name参数为 纠正的表名
  2. 属性名 ≠ 字段名，在属性上添加 `@Column`注解 name参数为 纠正的字段名
- 如果 前面有导入 MyBatis构件的类 ，需要更改为 tk-mybatis构件的类
- 接口一旦继承了 `tk.mybatis.mapper.common.Mapper`接口 就可实现以下Mapper通用方法

**Mapper通用方法** 

| 返回      | 方法                                                         | 说明                                                         |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| List`<T>` | select(T record)                                             | 查询 根据实体类属性值进行查询                                |
| T         | selectByPrimaryKey(Object key)                               | 查询 根据主键进行查询                                        |
| List`<T>` | selectAll()                                                  | 查询 所有结果                                                |
| T         | selectOne(T record)                                          | 查询 根据实体类属性值进行查询，只能返回一个，多个则异常      |
| int       | selectCount(T record)                                        | 查询 表中的总条数                                            |
| int       | insert(T record)                                             | 插入 一个实体类 ，null属性值也会保存，而不是库中的默认值     |
| int       | insertSelective(T record)                                    | 插入 一个实体类 ，null属性值不会保存，而应用库中的默认值     |
| int       | updateByPrimaryKey(T record)                                 | 更新 根据主键更新所有字段，null属性值也会被更新              |
| int       | updateByPrimaryKeySelective(T record)                        | 更新 根据主键更新字段，null属性值不会被更新                  |
| int       | delete(T record)                                             | 删除 根据实体类属性值进行条件删除                            |
| int       | deleteByPrimaryKey(Object key)                               | 删除 根据主键进行删除                                        |
| List`<T>` | selectByExample(Object example)                              | 查询 根据Example条件进行查询                                 |
| int       | selectByExample(Object example)                              | 查询 根据Example条件进行查询总条数                           |
| int       | updateByExample(@Param("record") T record, @Param("example") Object example) | 更新 根据Example条件进行更新为 record实体类 全部属性，null属性值也会被更新 |
| int       | updateByExampleSelective(@Param("record") T record, @Param("example") Object example) | 更新 根据Example条件进行更新为 record实体类 全部属性，null属性值不会被更新 |
| int       | deleteByExample(Object example)                              | 删除 根据Example条件进行删除                                 |

#### 应用实现

以下应用实例：

**数据库展示**

`tb_user`表 （其他数据自行引入）

| 字段名    | 类型    | 主键 |
| --------- | ------- | ---- |
| id        | bigint  | T    |
| user_name | varchar | F    |
| password  | varchar | F    |
| name      | varchar | F    |
| age       | int     | F    |
| sex       | int     | F    |
| birthday  | date    | F    |

1. 引入依赖 `pom.xml` 

   ```xml
   <dependency>
       <groupId>tk.mybatis</groupId>
       <artifactId>mapper-spring-boot-starter</artifactId>
       <version>2.0.2</version>
   </dependency>
   ```

2. 创建 User实体类 （指定库中的表列属性信息）

   ```java
   package com.pojo;
   
   import javax.persistence.*;
   import java.io.Serializable;
   import java.util.Date;
   
   @Table(name = "tb_user")
   public class User implements Serializable {
       
       //主键 ，主键策略为 自增
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       // 用户名
       @Column(name = "user_name")
       private String userName;
       // 密码
       private String password;
       // 姓名
       private String name;
       // 年龄
       private Integer age;
       // 性别，1男性，2女性
       private Integer sex;
       // 出生日期
       private Date birthday;
       
       //省略 get 、 set 和 toString
   }
   ```

3. 创建 `UserMapping`接口 ，全限定名 com.mapping.UserMapping （继承接口即可实现Mapper通用方法）

   ```java
   package com.mapping;
   
   import com.domain.User;
   import tk.mybatis.mapper.common.Mapper;
   
   public interface UserMapping extends Mapper<User> {
   }
   ```

   > 不要忘记应用的是 tk.mybatis.mapper.common.Mapper接口 构件

4. 使用 @MapperScan注解 扫描的包
   在 `@SpringBootApplication`注解下的启动类，添加@MapperScan注解 value参数为 扫描的包路径

   ```java
   package com;
   // import org.mybatis.spring.annotation.MapperScan;
   import tk.mybatis.spring.annotation.MapperScan;
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   
   // 启动类
   @SpringBootApplication
   @MapperScan("com.mapping")
   public class Application {
       public static void main(String[] args) {
           SpringApplication.run(Application.class , args);
       }
   }
   ```

   > 不要忘记应用的是 tk.mybatis.mapper.common.Mapper接口 构件

5. 测试

   ```java
   package com.mapping;
   
   import com.domain.User;
   import junit.framework.TestCase;
   import org.junit.Test;
   import org.junit.runner.RunWith;
   import org.springframework.beans.factory.annotation.Autowired;
   import org.springframework.boot.test.context.SpringBootTest;
   import org.springframework.test.context.junit4.SpringRunner;
   import tk.mybatis.mapper.entity.Example;
   import java.util.List;
   
   @RunWith(SpringRunner.class)
   @SpringBootTest
   public class UserMappingTest extends TestCase {
       
       @Autowired
       private UserMapping userMapping;
       
       //查所有
       @Test
       public void testFindAll() {
           userMapping.selectAll().forEach(user -> {
               System.out.println(user);
           });
       }
       
       //查id
       @Test
       public void testFindById() {
           User user = userMapping.selectByPrimaryKey(5);
           System.out.println("user : " + user);
       }
       
       //插入
       @Test
       public void testInsert(){
           User user = new User();
           user.setUserName("lishi");
           user.setName("李四");
           user.setPassword("1");
           user.setAge(21);
           user.setSex(1);
           int i = userMapping.insertSelective(user);
           System.out.println("插入结果 : " + i);
       }
       
       // Example条件查询
       @Test
       public void testFindByExample() {
           Example example = new Example(User.class);
           
           // 展示1
           // SQL：SELECT * FROM tb_user WHERE ( name like '%张%' )
           example.createCriteria().andLike("name","%张%");
           
           // 展示2
           // SQL：SELECT * FROM tb_user WHERE ( name like '%张%' and password = '1' )
           // example.createCriteria().andLike("name","%张%").andEqualTo("password","1");
           userMapping.selectByExample(example).forEach(user -> {
               System.out.println(user);
           });
       }
   }
   ```

#### 自定义映射文件查询

自定义映射文件用于进行复杂的SQL语句进行对库编辑

应用前说明：

- 应用后 驼峰、下划线 命名失效

**应用实现**
在以上代码原有的基础上进行编辑！

1. 在SpringBoot的 全局属性(application.properties文件) 添加参数

   ```properties
   # mybatis 别名扫描
   mybatis.type-aliases-package=com.pojo
   # mapper.xml文件位置 (使用在有映射的前提)
   mybatis.mapper-locations=classpath:mappers/*.xml
   ```

2. 创建 `UserMapper.xml`文件 资源路径 resources/mappers/UserMapper.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="com.mapping.UserMapping">
   
       <select id="findByUser" resultType="user">
           SELECT * FROM
           tb_user
           <where>
               <if test="name != null">
                   name like '%${name}%'
               </if>
               <if test="password != null">
                   and password like '%${password}%'
               </if>
           </where>
       </select>
   
   </mapper>
   ```

   > 注意 mapper节点 映射指定的接口路径

3. 编辑 `UserMapping`接口 ，全限定名 com.mapping.UserMapping 

   ```java
   package com.mapping;
   
   import com.domain.User;
   import tk.mybatis.mapper.common.Mapper;
   import java.util.List;
   
   public interface UserMapping extends Mapper<User> {
       // 自定义复杂sql方法
       public List<User> findByUser(User user);
   }
   ```

4. 测试， 在 UserMappingTest测试类 中

   ```java
   // 自定义方法
   @Test
   public void testfindByUser() {
       
       User user = new User();
       user.setName("张");
       // user.setPassword("1");g
       userMapping.findByUser(user).forEach(u -> {
           System.out.println(u);
       });
       
   }
   ```

### 视图框架整合

Thymeleaf是用于 Web 和 独立环境 的Java模板引擎（类似于JSP）

SpringBoot 为 Thymeleaf 提供一系列的默认配置，Thymeleaf依赖 一旦导入，项目会自动配置

**优点：**

- Thymeleaf 在有网络和无网络的环境下皆可运行，通过美工实现页面数据的动静结合
  有网络则覆盖静态显示的内容数据
  无网络则显示默认静态的内容数据
- SpringBoot完美整合，springboot默认整合thymeleaf

#### 表达式

Thymeleaf有3表达式

- [变量表达式`${...}`](#变量表达式) 
- [选择表达式`*{...}`](#选择表达式) 
- [URL表达式`@{...}`](#URL表达式) 

##### 变量表达式

==${...}== 变量表达式可以直接过去域中的数据。接收方式和JSP一样，但使用呈现方式不一样

**示例：**（后端响应变量 "good" : "Thymeleaf very Good!"）

```html
<!--响应的变量 good的值为 “Thymeleaf very Good!” -->
<h5>表达式</h5>
<span>${good}</span><br>
<span th:text="${good}">你好 thymleaf</span><br>
<span>${good}</span><br>

<!-- 结果预览
表达式
${good}
Thymeleaf very Good!
${good}
-->
```

##### 选择表达式

==*{...}== 选择表达式 也称 星号表达式，不过这一操作需要预先通过选择一个对象进行充当上下文容器的变量执行

**示例：**（后端响应变量 {"cat" : "猫","dog" : "狗"}）

```html
<div th:object="${pet}">
    <span th:text="*{dog}"></span> <br>
    <span th:text="*{cat}"></span> <br>
</div>

<!-- 浏览器预览结果
狗
猫
-->
```

##### URL表达式

URL表达式 是把一个有效的信息 添加到URL，也是URL重写

重写形式有3种：

- url表达式 
- 文本替换 
- 字符串拼接 

```html
<!-- url表达式 （无参
	结果：href="main.html" 
-->
<a th:href="@{/main}">

<!-- url表达式（有参
	后端响应：{user.id : 1,user.name : "张三"}
	结果：href="/del?id=1&name=张三" 
-->
<a th:href="@{/del(id=*{id},name=${user.name})}">删除</a>
    
<!-- 文本替换
	结果：href="/update/1" 
-->
<a th:href="@{|/update/*{id}|}">修改</a>

<!-- 字符串拼接
	 结果：href="/approve/1" 
-->
<a th:href="'/approve/'+*{id}">审核</a>
```

#### th属性

| 关键字        | 功能介绍                                     | 案例                                                         |
| :------------ | :------------------------------------------- | :----------------------------------------------------------- |
| `th:id`       | 替换id                                       | `<input th:id="'xxx' + ${collect.id}"/>`                     |
| `th:text`     | 文本替换                                     | `<p th:text="${user.name}">张三</p>`                         |
| `th:utext`    | 支持html的文本替换                           | `<p th:utext="${htmlContent}">content</p>`                   |
| `th:object`   | 替换对象                                     | `<div th:object="${user}">`                                  |
| `th:value`    | 属性赋值                                     | `<input th:value="${user.id}"/>`                             |
| `th:with`     | 变量赋值运算                                 | `<div th:with="isEven=${prodStat.count}%2==0"></div>`        |
| `th:style`    | 设置样式                                     | `th:style="'display:' + @{(${sitrue} ? 'none' : 'inline-block')} + ''"` |
| `th:onclick`  | 点击事件                                     | `th:onclick="'getCollect()'"`                                |
| `th:each`     | 属性赋值                                     | `<tr th:each="user,userStat:${users}"/>`                     |
| `th:if`       | 判断条件                                     | `<a th:if="${userId == collect.userId}" >`                   |
| `th:unless`   | 和th:if判断相反                              | `<a th:href="@{/login}" th:unless=${session.user != null}>Login</a>` |
| `th:href`     | 链接地址                                     | `<a th:href="@{/login}" th:unless=${session.user != null}>Login</a> />` |
| `th:switch`   | 多选择 配合th:case 使用                      | `<div th:switch="${user.role}">`                             |
| `th:case`     | th:switch的一个分支                          | `<p th:case="'admin'">User is an administrator</p>`          |
| `th:fragment` | 布局标签，定义一个代码片段，方便其它地方引用 | `<div th:fragment="alert">`                                  |
| `th:include`  | 布局标签，替换内容到引入的文件               | `<head th:include="layout :: htmlhead" th:with="title='xx'"></head> />` |
| `th:replace`  | 布局标签，替换整个标签到引入的文件           | `<div th:replace="fragments/header :: title"></div>`         |
| `th:selected` | selected选择框 选中                          | `th:selected="(${xxx.id} == ${configObj.dd})"`               |
| `th:src`      | 图片类地址引入                               | `<img class="img-responsive" alt="App Logo" th:src="@{/img/logo.png}"  />` |
| `th:inline`   | 定义js脚本可以使用变量                       | `<script type="text/javascript" th:inline="javascript">`     |
| `th:action`   | 表单提交的地址                               | `<form action="subscribe.html" th:action="@{/subscribe}">`   |
| `th:remove`   | 删除某个属性                                 | `<tr th:remove="all">` <br />1. all: 删除所有<br />2. body: 不删本身, 删除其所有的子标签<br />3. tag: 删除本身，但不删除它的子标签<br />4. all-but-first: 仅保留第一个子标签，其他删除<br />5. none: 什么也不做 |
| `th:attr`     | 设置标签属性，多个属性可以用逗号分隔         | `<img th:attr="src=@{/image/aa.jpg},title=#{logo}"/>` 一般比较少使用（难以阅读 |

**常用th属性 示例：**

**条件判断 `th:if`/`th:unless`** 
判断属性是否成立，如果成立则显示

```html
<!-- 响应：{"numbers":[1,2,3]} -->
<a th:if="${numbers.length > 0}">测试1</a><br>
<a th:if="${numbers.length <= 0}">测试2</a><br>
<a th:unless="${numbers.length <= 0}">测试3</a><br>

<!-- 预览结果
测试1

测试3
-->
```

**for循环 `th:each`** 

组成拆解：==<th th:each="遍历对象,状态对象:遍历集合对象">...</th>== 

status状态对象的属性：

| 类型    | status属性 | 说明                       |
| ------- | ---------- | -------------------------- |
| int     | `index`    | 迭代当前对象（从0开始）    |
| int     | `count`    | 迭代当前对象（从1开始）    |
| int     | `size`     | 被迭代的对象大小           |
| -       | `current`  | 当前迭代变量               |
| boolean | `even`     | 当前迭代值 是否为 偶数     |
| boolean | `odd`      | 当前迭代值 是否为 奇数     |
| boolean | `first`    | 当前迭代值 是否为 第一个   |
| boolean | `last`     | 当前迭代值 是否为 最后一个 |

```html
<!-- 
	响应："users":[{
			"id":"1",
			"name":"张三",
			"userName":"zhangsan",
			"age":"23",
			"sex":1,
			"birthday":"1980-02-30"
		},...]
-->
<tr th:each="user ,status : ${users}" th:object="${user}">
    <td th:text="${status.count}">1</td>
    <td th:text="*{id}">233</td>
    <td data-th-text="*{name}">张三</td>
    <td th:text="${user.userName}">zhangsan</td>
    <td th:text="${user.age}">20</td>
    <td th:text="${user.sex} == 1 ? '男': '女'">男</td>
    <td th:text="${user.birthday}">1980-02-30</td>
    <td>
        <!--不同参数 形式-->
        <a th:href="@{/del(id=*{id},name=${user.name})}">删除</a>
        <!--文本替换 形式-->
        <a th:href="@{|/update/*{id}|}">修改</a>
        <!--字符串拼接 形式-->
        <a th:href="'/approve/'+*{id}">审核</a>
    </td>
</tr>
```

####  内置对象

Thymeleaf提供了一系列Utiliy对象，可直接通过#进行访问：

- **strings：** 字符串工具对象，常用方法有：equals、equalsIgnoreCase、length、trim、toUpperCase、toLowerCase、indexOf、substring、replace、startsWith、endsWith，contains 和 containsIgnoreCase 等
- **numbers：** 数字工具对象，常用的方法有：formatDecimal 等
- **bools：** 布尔工具对象，常用的方法有：isTrue 和 isFalse 等
- **arrays：** 数组工具对象，常用的方法有：toArray、length、isEmpty、contains 和 containsAll 等；
- **lists/sets：** List/Set 集合工具对象，常用的方法有：toList、size、isEmpty、contains、containsAll 和 sort 等
- **maps：** Map 集合工具对象，常用的方法有：size、isEmpty、containsKey 和 containsValue 等
- **dates：** 日期工具对象，常用的方法有：format、year、month、hour 和 createNow 等

```html
<h4>dates</h4>
<p th:text="${#dates.createNow()}">获取当前日期</p>
<p th:text="${#dates.format(#dates.createNow())}">日期格式化</p>
<p th:text="${#dates.format(#dates.createNow(),'yyyy-MM-dd HH:mm:ss')}">日期自定义格式化</p>
<!-- 预览结果
dates
Mon Sep 20 14:57:12 CST 2021
2021年9月20日 下午02时57分12秒
2021-09-20 14:57:12
-->

<!-- 响应："good":"Thymeleaf very Good!"-->
<h4>strings</h4>
<p th:text="${#strings.substring(good, 6, 9)}">截取字符串</p>
<p th:text="${#strings.length(good)}">获得长度</p>
<p th:text="${#strings.randomAlphanumeric(6)}">随机字符串</p>
<p th:text="${#strings.equals(good, 'hello')}">比较</p>
<!--  预览结果
eaf
20
NI5QPI
false
-->
```

更多了解：[Thymeleaf](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#appendix-b-expression-utility-objects) （19 Appendix B: Expression Utility Objects）

#### 首次应用

**前提说明：**

- 在 `.html`文件 需要添加以下的命名空间（否则无法识别 th属性标签
  ==<html leng="en" xmlns:th="http://www.thymeleaf.org"> .... </html>== 

- 后端的 资源文件 需要存放指定目录 `classpath:/templates/*`  

  **默认前缀：** `templates/` 
  **默认后缀：** `.html` 

  ![](http://sanscan12.gitee.io/blogimg/Content/Spring/SpringBoot02.png)

- 测试优化。在修改页面的时，由于缓存并非立即呈现效果，因此可通过添加以下全参关闭缓存

  ```properties
  # 开发阶段关闭 thymeleaf的模板缓存
  spring.thymeleaf.cache=false
  ```

**应用步骤：**

1. 引入依赖

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-thymeleaf</artifactId>
   </dependency>
   ```

2. 创建前端文件。路径：==templates/ThymeleafView.html==

   ```html
   <!DOCTYPE html>
   <html lang="en" xmlns:th="http://www.w3.org/1999/xhtml">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
       <ul>
           <li th:each="user,userStat : ${userList}" th:object="${user}">
               <span th:text="*{id}"></span> ==
               <span th:text="*{name}"></span> ==
               <span th:text="${user.age}"></span>
           </li>
       </ul>
   </body>
   </html>
   ```

3. 封装 User实体类

   ```java
   public class User {
       String id;
       String name;
       int age;
       
       // 构造全参/无参 、set 、get方法省略。。。
   }
   ```

4. 编辑 Controller控制器

   ```java
   @Controller
   public class HelloController {
   
       @GetMapping("/findAll")
       public ModelAndView findAll() {
           ModelAndView view = new ModelAndView();
   
           List<User> list = new ArrayList<User>(){{
               add(new User("2","张三",33));
               add(new User("3","李四",34));
               add(new User("4","王五",35));
               add(new User("5","赵六",36));
           }};
   
           view.addObject("userList",list);
           view.setViewName("ThymeleafView");
           return view;
       }
   }
   ```

5. 启动直接访问即可，结果示例

   ```html
   <body>
       <ul>
           <li>
               <span>2</span> ==
               <span>张三</span> ==
               <span>33</span>
           </li>
           <li>
               <span>3</span> ==
               <span>李四</span> ==
               <span>34</span>
           </li>
           <li>
               <span>4</span> ==
               <span>王五</span> ==
               <span>35</span>
           </li>
           <li>
               <span>5</span> ==
               <span>赵六</span> ==
               <span>36</span>
           </li>
       </ul>
   </body>
   ```

### Shiro整合

Shiro是开源的安全框架，可以完全处理身份验证，授权，会话加密等

这里只讲解 SpringBoot 整合 Shrio，进一步了解，进入Shiro文章进行深入学习

**应用步骤：**

1. **引入依赖** 

    ```xml
    <!-- Shiro -->
    <dependency>
        <groupId>org.apache.shiro</groupId>
        <artifactId>shiro-spring-boot-web-starter</artifactId>
        <version>1.4.0-RC2</version>
    </dependency>
    ```

2. **创建配置类** `ShiroConfig`

   ```java
   @Configuration
   @Component
   public class ShiroConfig {
   
       @Bean
       public ShiroFilterFactoryBean shiroFilterFactoryBean(org.apache.shiro.mgt.SecurityManager securityManager) {
   
           ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
           shiroFilterFactoryBean.setSecurityManager(securityManager);
   
           // 定义默认路径
           shiroFilterFactoryBean.setLoginUrl("/dologin");
           shiroFilterFactoryBean.setSuccessUrl("/index");
           shiroFilterFactoryBean.setUnauthorizedUrl("/refuse.html");
   
           // 过滤器链
           LinkedHashMap<String, String> filterChainDefinitionMap = new LinkedHashMap<>();
           filterChainDefinitionMap.put("/", "anon");
           filterChainDefinitionMap.put("/static/css/**", "anon");
           filterChainDefinitionMap.put("/static/js/**", "anon");
           filterChainDefinitionMap.put("/static/images/**", "anon");
           filterChainDefinitionMap.put("/static/register", "anon");
           filterChainDefinitionMap.put("/toRegister", "anon");
           filterChainDefinitionMap.put("/login.html", "anon");
           filterChainDefinitionMap.put("/logout", "logout");
           filterChainDefinitionMap.put("/**", "authc");
   
           // 配置过滤器
           shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
   
           // 自定义过滤器
           // Map<String, Filter> filters = new HashMap<>();
           // filters.put("authc", new CustomFormAuthenticationFilter());
           // shiroFilterFactoryBean.setFilters(filters);
   
           return shiroFilterFactoryBean;
       }
   
       @Bean
       public ShiroFilterChainDefinition shiroFilterChainDefinition() {
           DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();
   
           // logged in users with the 'admin' role
           //chainDefinition.addPathDefinition("/admin/**", "authc, roles[admin]");
   
           // logged in users with the 'document:read' permission
           //chainDefinition.addPathDefinition("/docs/**", "authc, perms[document:read]");
   
           // all other paths require a logged in user
           //chainDefinition.addPathDefinition("/logout", "logout");
           //chainDefinition.addPathDefinition("/**", "authc");
           return chainDefinition;
       }
   
       @Bean
       public DefaultWebSecurityManager securityManager(Realm realm) {
           DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
           securityManager.setRealm(realm);
   //       securityManager.setRememberMeManager(rememberMeManager());
   //       securityManager.setCacheManager(getEhCacheManager());
   //       securityManager.setSessionManager(sessionManager());
           return securityManager;
       }
   
       @Bean
       public Realm shiroRealm() {
           return new ShiroRealm();
       }
   
   //    /**
   //     * 密码校验规则HashedCredentialsMatcher
   //     * 这个类是为了对密码进行编码的 ,
   //     * 防止密码在数据库里明码保存 , 当然在登陆认证的时候 ,
   //     * 这个类也负责对form里输入的密码进行编码
   //     * 处理认证匹配处理器：如果自定义需要实现继承HashedCredentialsMatcher
   //     */
   //    @Bean("hashedCredentialsMatcher")
   //    public HashedCredentialsMatcher hashedCredentialsMatcher() {
   //        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
   //        //指定加密方式为MD5
   //        credentialsMatcher.setHashAlgorithmName("MD5");
   //        //加密次数
   //        credentialsMatcher.setHashIterations(1024);
   //        credentialsMatcher.setStoredCredentialsHexEncoded(true);
   //        return credentialsMatcher;
   //    }
   
   
   //    @Bean("authRealm")
   //    @DependsOn("lifecycleBeanPostProcessor")//可选
   //    public AuthRealm authRealm(@Qualifier("hashedCredentialsMatcher") HashedCredentialsMatcher matcher) {
   //        AuthRealm authRealm = new AuthRealm();
   //        authRealm.setAuthorizationCachingEnabled(false);
   //        authRealm.setCredentialsMatcher(matcher);
   //        return authRealm;
   //    }
   }
   ```

3. **创建领域**

   ```java
   public class ShiroRealm extends AuthorizingRealm {
   
       @Autowired
       private AuctionuserService auctionuserService;
   
       @Override
       protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
           return null;
       }
   
       /**
        * 身份验证
        * @param token 包含用户主体和凭据的身份验证令牌。
        * @return
        * @throws AuthenticationException
        */
       @Override
       protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
           String username = (String) token.getPrincipal();
           Auctionuser user = auctionuserService.findUserByName(username);
           if (user == null) return null;
           return new SimpleAuthenticationInfo(user, user.getUserPassword(),"ShiroRealm");
       }
   }
   ```

4. 三个步骤即可实现引入Shiro（如果需要其他功能可以在配置类中进行添加！）



### MyBatis Plus整合

MyBatis Plus是MyBatis的增强工具，在MyBatis的基础上做了增强不改变的开发实现，从而提高效率。

官方文档：https://baomidou.com/pages/24112f/

**特点：**

- 无侵入。只做增强不做改变
- 消耗小。启动只注入CURD
- 增强CRUD操作。内置通用Mapper
- 内置代码生成器。采用Maven插件生成映射
- 分页插件多功能。支持多种数据库
- 内置全局拦截器。可分析增删改过程进行阻断

#### 首次应用

应用大致流程 : 

1. 引入pon.xml依赖
2. 更改库数据相关配置
3. 启动器类 添加@MapperScan注解

**应用**

1. **引入依赖 pom.xml**

   ```xml
   <!-- MyBatisPlus -->
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus-boot-starter</artifactId>
       <version>3.4.2</version>
   </dependency>
   <!-- mysql驱动 -->
   <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>5.1.48</version>
   </dependency>
   <!-- 连接池 -->
   <dependency>
       <groupId>com.alibaba</groupId>
       <artifactId>druid-spring-boot-starter</artifactId>
       <version>1.1.20</version>
   </dependency>
   ```
   
2. **配置文件 application**

   ```properties
   # MyBatis
   # 连接池
   spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
   # 驱动
   spring.datasource.driver-class-name=com.mysql.jdbc.Driver
   # url/账号/密码
   spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false
   spring.datasource.username=root
   spring.datasource.password=root
   mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
   ```
   
   > 这里连接库的用户名和密码可以省略不写，或者随意设定
   
3. 创建 库数据 和 创建实体类 (省略 
   
5. 创建 UserMapper接口

   ```java
   @Mapper
   public interface UserMapper extends BaseMapper<User> {}
   ```
   
   > 继承实现Mapper通用方法
   
6. SpringBoot 启动类 添加注解 @MapperScan

   ```java
   @SpringBootApplication
   @MapperScan("com.mapper")
   public class Application {
       public static void main(String[] args) {
           SpringApplication.run(Application.class , args);
       }
   }
   ```

   > `@MapperScan`注解 扫描 Mapper文件夹 的包路径

7. 测试 

   ```java
   // 启动器Spring测试启动环境
   @RunWith(SpringRunner.class)
   // 启动类
   @SpringBootTest(classes = Application.class)
   public class UserMapperTest {
       
       @Autowired
       private UserMapper userMapper;
       
       @Test
       public void testFindByAll() {
           
           List<User> users = userMapper.selectList(null);
           users.forEach(System.out::println);
           // Assert.assertEquals(26 , users.size());
       }
   }
   ```

#### 注解配置

**常用注解说明：**

| 注解          | 值                                                           | 说明             |
| ------------- | ------------------------------------------------------------ | ---------------- |
| `@TableName`  | value：纠正表名                                              | 表名注解         |
| `@TableId`    | value：纠正主键字段名<br />type：主键策略类型                | 主键注解         |
| `@TableField` | value：纠正字段名<br />exist：是否为库字段<br />fill：默认值填充 | 字段注解(非主键) |

更多注解：https://baomidou.com/pages/223848/

> PS : @TableId/@TableField 纠正后 set方法也需要修改 , 因 使用set注入 , 否则失效

#### 内置 CRUD

官网说明  : [更多详细](https://baomidou.com/pages/49cc81/#mapper-crud-%E6%8E%A5%E5%8F%A3) 

##### 新增

```java
@Test
    public void testInsert() {
        Assert.assertTrue(userMapper.insert(new User().setName("张三").setAge(3)) > 0);
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)
        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)
        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
        User(id=7, name=张三, age=3, email=null, phone=null)
     */
```

##### 删除

```java
@Test
    public void testDelById() {
        Assert.assertTrue(userMapper.deleteById(3) > 0);
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)
        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
     */
    
    @Test
    public void testDeletes1() {
        Assert.assertTrue(userMapper.delete(new QueryWrapper<User>().like("name","J")) > 0);
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
     */
    
    @Test
    public void testDeletes2() {
        Assert.assertTrue(userMapper.delete(Wrappers.<User>query().like("name","J")) > 0);
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
     */
    
    @Test
    public void testDeletes3() {
        Assert.assertTrue(userMapper.delete(Wrappers.<User>query().lambda().like(User::getName,"J")) > 0);
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
    */
    
    @Test
    public void testDeletes4() {
        Assert.assertTrue(userMapper.delete(new QueryWrapper<User>().lambda().like(User::getName,"J")) > 0);
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
    */
```

##### 更改

```java
@Test
    public void testUpdateById() {
        userMapper.updateById(new User().setId(3L).setName("先科"));
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)
        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)
        User(id=3, name=先科, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
     */
    
    @Test
    public void testUpdate1() {
        userMapper.update(null, Wrappers.<User>update().set("name","kkkBbb").like("name","Tom"));
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)
        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)
        User(id=3, name=先科, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
     */
    
    @Test
    public void testUpdate2() {
        userMapper.update(new User().setName("kkkBbb"), Wrappers.<User>update().like("name","Tom"));
        userMapper.selectList(null).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)
        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)
        User(id=3, name=kkkBbb, age=28, email=test3@baomidou.com, phone=null)
        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)
        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)
        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)
     */
```

##### 查询

```java
@Test
    public void testFindByBasic() {
        System.out.println(userMapper.selectList(Wrappers.<User>query().eq("name","Jone")));
    }
    /*
        [User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)]
     */
    
    @Test
    public void testFindProjection1() {
        userMapper.selectList(new QueryWrapper<User>().select("id","name")).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=null, email=null, phone=null)
        User(id=2, name=Jack, age=null, email=null, phone=null)
        User(id=3, name=Tom, age=null, email=null, phone=null)
        User(id=4, name=Sandy, age=null, email=null, phone=null)
        User(id=5, name=kaikeba, age=null, email=null, phone=null)
        User(id=6, name=Billie, age=null, email=null, phone=null)
     */
    
    @Test
    public void testFindProjection2() {
        userMapper.selectList(new QueryWrapper<User>().select("id","name").like("name","J")).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=null, email=null, phone=null)
        User(id=2, name=Jack, age=null, email=null, phone=null)
     */
    
    @Test
    public void testFindProjection3() {
        userMapper.selectList(new QueryWrapper<User>().select("id","name").lambda().like(User::getName,"J")).forEach(System.out::println);
    }
    /*
        User(id=1, name=Jone, age=null, email=null, phone=null)
        User(id=2, name=Jack, age=null, email=null, phone=null)
     */
```

#### 自定义 SQL

自定义SQL是写在 Mapper接口的方法上 , 值直接写SQL语句

| 注解      | 说明 |
| --------- | ---- |
| `@Insert` | 插入 |
| `@Update` | 更新 |
| `@Delete` | 删除 |
| `@Select` | 查询 |

CRUD按照指定的规则编写SQL即可 , 如果需要传递参数 [点击跳转](#传参操作) 

```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    @Select("select * from users")
    List<User> findAll();
}
```

##### 条件构造器

条件构造器主要作用在 SQL语句中添加Where条件 , 从而自动生成约束的SQL . 主要比较贴合 Hibernate 的使用方式 

条件构造器两大分类 : (它们的父类  AbstractWrapper抽象类)

- **QueryWrapper ** 
- **UpdateWrapper** 

> 以上有各自独有的属性详细自行官网查询  [条件构造器更多详细](https://baomidou.com/pages/10c804/#abstractwrapper) 

**应用 :**  

```java
// 最终Where约束语句 (默认全参存在)
// select xxx from xxx where
// 		(ex.del_flag=0 AND ex.examine_user_id=su.id AND su.office_id=so.id) and
// 		(ex.type=?) and (su.name like '%?%') and (so.id=?);
@Override
public List<ExamineDo> selectByCondition(Map<String, Object> map) {

    QueryWrapper<ExamineDo> query = new QueryWrapper<>();

    // 三表连接的 关键字段的 SQL约束代码
    query.apply("ex.del_flag=0 AND ex.examine_user_id=su.id AND su.office_id=so.id");

    /**
     * SQL约束拼接参数说明：
     *   参数1.判断该对象是否可行（指该属性数据是有效且不为空
     *   参数2.指定比较的字段 字符串（一般指定的字符串
     *   参数3.指定比较的数据 外面获取到的
     */
    query.eq(map.containsKey("type") && !ObjectUtils.isEmpty(map.get("type")),"ex.type",map.get("type"))
            .like(map.containsKey("name") && !ObjectUtils.isEmpty(map.get("name")),"su.name",map.get("name"))
            .eq(map.containsKey("officeId") && !ObjectUtils.isEmpty(map.get("officeId")),"so.id",map.get("officeId"));
	// Mapper传递对象即可
    return baseMapper.selectByCondition(query);
}
```

##### 传参操作

手写SQL多多少少都会需要参数的传递 , 因此有以下三种方式进行传递参数 : 

1. **实体类** 
   根据实体的 **属性** 进行匹配信息
2. **Map**
   根据Map哈希中的 **K键** 匹配 V值
3. **@Param**
   根据 **参数值** 映射匹配
4. **条件构造器**
   只需添加一个对象即可自动生成 约束SQL
   官方说明 : [条件构造器使用方式](https://baomidou.com/pages/10c804/#%E4%BD%BF%E7%94%A8-wrapper-%E8%87%AA%E5%AE%9A%E4%B9%89sql) 

**示例：**

````java
// 实体类
// 实体类包含的属性JSON展示 Users{id,name}
@Select("SELECT su.*  " +
        "FROM  " +
        "sys_user su " +
        "WHERE " +
        "su.id= #{id} " +
        "AND su.name= #{name} " )
List<SysUser> findByid(Users user);

// Map
// map = {id:23,name:"张三"}
@Select("SELECT su.*  " +
        "FROM  " +
        "sys_user su " +
        "WHERE " +
        "su.id= #{id} " +
        "AND su.name= #{name} " )
List<SysUser> findByid(Map<String,Object> map);

// @Param
@Select("SELECT su.*  " +
        "FROM  " +
        "sys_user su " +
        "WHERE " +
        "su.id= #{id} " )
List<SysUser> findByid(@Param("id")Integer id);

// 条件构造器
@Select("select * from mysql_data ${ew.customSqlSegment}")
List<MysqlData> getAll(@Param(Constants.WRAPPER) Wrapper wrapper);
````

#### 多表查询

多个表查询难免会有些稍微复杂的SQL . 多表查询分为 一对多/一对一/多对多 三种类型

| 注解       | 以往标签          | 说明                                                         |
| ---------- | ----------------- | ------------------------------------------------------------ |
| `@Result`  | `<id>`/`<Result>` | 结果集封装 . 包含有以下属性 : <br />- column : 数据表字段名称<br />- property : 类中对应的属性名<br />- one : 与@One搭配 , 进行一对一的映射<br />- many : 与@Many搭配 , 进行一对多的映射 |
| `@Results` | `<resultMap>`     | 和@Result 使用 , 封装 一个/多个 结果集                       |
| `@One`     | `<assocation>`    | 一对一结果集封装 , 使用格式如下 : <br />@Result(column="xx",property="xx",one=@One(select="xx",...)) |
| `@Many`    | `<collection>`    | 一对多结果集封装 , 使用格式如下 : <br />@Result(column="xx",property="xx",many=@Many(select="xx",...)) |

> **注意 :** 
>
> - 一旦使用了 @Results注解 封装的当前对象全部属性都要重新手写
> - 使用 @One/@Many 注解 , 一般情况使用 select属性值 指定全限定名类的方法(如: ById/...)

**应用**

主要编写核心部分 , 其他代码简单表示即可

**User 用户实体**

| 类型       | 名称      | 表对应的字段  | 注解规则                   |
| ---------- | --------- | ------------- | -------------------------- |
| int        | id        | id            |                            |
| String     | username  | username      |                            |
| String     | password  | password      |                            |
| List<User> | orderList | oid(提取二查) | @TableField(exist = false) |

**Order 订单实体**

| 类型   | 名称      | 表对应的字段  | 注解规则                   |
| ------ | --------- | ------------- | -------------------------- |
| String | id        | id            |                            |
| Date   | ordertime | ordertime     |                            |
| double | total     | total         |                            |
| User   | user      | uid(提取二查) | @TableField(exist = false) |

**一对多** 一人有多个订单
UserMapper接口

```java
@Mapper
public interface UserMapper extends BaseMapper<User> {
    // 查所用用户并且包含订单
    @Select("select * from user")
    @Results({
            @Result(column = "id", property = "id"),
            @Result(column = "username", property = "username"),
            @Result(column = "password", property = "password"),
            @Result(column = "id", property = "orderList",javaType = List.class,
                    many = @Many(select = "com.sans.demoapplication.mapper.OrderMapper.findByUId"))
    })
    List<User> findAll();
}
```

> @Many注解中属性seelct的值 : 是指定路径类的方法

**多对多** 每个订单必须有一个用户
OrderMapper接口

```java
@Mapper
public interface OrderMapper extends BaseMapper<Order> {

    // 查所有
    @Select("SELECT  id,ordertime,total,uid  FROM `order`")
    @Results({
            @Result(column = "id",property = "id"),
            @Result(column = "ordertime",property = "ordertime"),
            @Result(column = "total",property = "total"),
            @Result(column = "uid", property = "user" ,javaType = User.class ,
                    one = @One(select = "com.sans.demoapplication.mapper.UserMapper.selectById"))
    })
    List<Order> findAllOrder();

    // 按uid 查订单
    @Select("select id,ordertime,total from `order` where uid=#{uid}")
    List<Order> findByUId(int uid);

}
```

> @One注解中属性seelct的值 : 是指定路径类的方法 (该类继承有 BaseMapper接口 里面有内置的CRUD)

#### 分页插件

以下分页功能的实现 , 基于以上的基础进行实现

分页应用方式有3种形式：

- [**内置分页**](#内置分页) 
- [**XML分页**](#XML分页) 
- [**PageHelper分页**](#PageHelper分页) 

**三种分页区别**

|               | 内置分页   | XML分页            | PageHelper分页 |
| ------------- | ---------- | ------------------ | -------------- |
| **jar包引入** | 无         | 无                 | 有             |
| **配置**      | 拦截器配置 | 全局配置 + 手写SQL | 引入Bean       |
| **分页信息**  | 简略       | 自定义             | 详细           |
| **复杂度**    | 低         | 高                 | 一般           |

##### 内置分页

1. 创建 mp配置类 `MybatisPlusConfig.java` ，全限定名类 : com.config.MybatisPlusConfig

   ```java
   package com.config;
   
   import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;
   import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   public class MybatisPlusConfig {
       
       /**
        * 分页插件
        */
       @Bean
       public PaginationInterceptor paginationInterceptor() {
           PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
           // 开启 count 的 join 优化,只针对 left join !!!
           paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));
           return paginationInterceptor;
       }
       
   }
   ```

2. 测试

   ```java
   @Autowired
   private UserMapper mapper;
   
   //····
   
   @Test
   public void testSelectPage() {
       
       Page<User> page = new Page<>(2, 3);
       Page<User> result = mapper.selectPage(page, Wrappers.<User>query());
   
       result.getRecords().forEach(System.out :: println);
       System.out.println("总数：" + result.getTotal());
       System.out.println("总页数：" + result.getPages());
       System.out.println("每行数：" + result.getSize());
   
       /**
        * 验证分页信息
        *      1. 总数 > 3
        *      2. 页总数 = 3
         */
       assertThat(result.getTotal()).isGreaterThan(3);
       assertThat(result.getRecords().size()).isEqualTo(3);
       
   }
   
   /*
   
   User(id=4, name=Jack, age=20, email=test2@baomidou.com)
   User(id=5, name=Jack, age=20, email=test2@baomidou.com)
   User(id=6, name=Jack, age=20, email=test2@baomidou.com)
   总数：17
   总页数：6
   每行数：3
   
   */
   ```

##### xml分页

1. 添加属性 ，全局配置文件 `application.yml` 

   ```yaml
   mybatis-plus :
     type-aliases-package : com.pojo.User
     mapper-locations: classpath:/mapper/*.xml
   ```

2. 映射类添加方法 `UserMapper.java` 

   ```java
   @Mapper
   public interface UserMapper extends BaseMapper<User> {
       
       /**
        * 用户列表分页查询 （xml）
        * Param()注解：替换了原旧名称进行应用参数属性 如 p.属性、c.属性
        * @param page 分页对象
        * @param conditioin 约束查询数据
        * @return
        */
       public Page<User> selectUserByPage(@Param ("p") IPage<User> page, @Param("c") User conditioin);
   }
   ```

3. 创建映射文件 `UserMapper.xml` ，路径 resources/mapper/UserMapper.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="com.mapper.UserMapper">
   
       <sql id="selectSql">
           SELECT `user`.id,`user`.name,`user`.age,`user`.email
           FROM user
       </sql>
   
       <select id="selectUserByPage" resultType="user">
           <include refid="selectSql"></include>
           <where>
               <if test="c.age !=null">
                   age = #{c.age}
               </if>
               <if test="c.email !=null">
                   and email like '%${c.email}%'
               </if>
           </where>
       </select>
   
   </mapper>
   ```

   > **注意：** namespace 属性指定的值是 实现的接口

4. 测试

   ```java
   //xml分页
   @Test
   public void testSelectUserByPage() {
       Page<User> page = new Page<>(1,2);
   
       User u = new User();
       u.setAge(20);
       u.setEmail("test2");
       
       Page<User> pr = mapper.selectUserByPage(page , u);
       
       
       System.out.println("总数：" + pr.getTotal());
       System.out.println("总页数：" + pr.getPages());
       System.out.println("每行数：" + pr.getSize());
       System.out.println("===========");
       pr.getRecords().forEach(System.out::println);
   }
   
   /*
   
   总数：13
   总页数：7
   每行数：2
   ===========
   User(id=2, name=Jack, age=20, email=test2@baomidou.com)
   User(id=3, name=Jack, age=20, email=test2@baomidou.com)
   
   */
   ```

   > **注意：** 约束条件查询结果条数 必须要 大于 分页每页数

##### pagehelper分页

1. 引入独有依赖 `pom.xml` 

   ```xml
   <!--pagehelper分页-->
   <dependency>
       <groupId>com.github.pagehelper</groupId>
       <artifactId>pagehelper</artifactId>
       <version>5.1.11</version>
   </dependency>
   ```

2. 编辑 mp配置类 `MybatisPlusConfig.java` ，全限定名：com.config.MybatisPlusConfig

   ```java
   package com.config;
   
   import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;
   import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;
   import com.github.pagehelper.PageInterceptor;
   import org.mybatis.spring.annotation.MapperScan;
   import org.springframework.context.annotation.Bean;
   import org.springframework.context.annotation.Configuration;
   
   @Configuration
   @MapperScan("com.mapper")
   public class MybatisPlusConfig {
       
       //···
       
       /**
        * pagehelper的分页插件
        */
       @Bean
       public PageInterceptor pageInterceptor() {
           return new PageInterceptor();
       }
       
   }
   ```

3. 映射类添加方法 `UserMapper.java` （可选测试）

   ```java
   package com.mapper;
   
   import com.baomidou.mybatisplus.core.mapper.BaseMapper;
   import com.baomidou.mybatisplus.core.metadata.IPage;
   import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
   import com.sans.pojo.User;
   import org.apache.ibatis.annotations.Mapper;
   import org.apache.ibatis.annotations.Param;
   
   import java.util.List;
   
   @Mapper
   public interface UserMapper extends BaseMapper<User> {
       
       //···
       
       /**
        * 用户列表分页查询 （pagehelper）
        * @param conditioin 约束查询数据
        * @return
        */
       public List<User> selectUserByPage2(User conditioin);
       
   }
   ```

4. 编辑映射文件 `UserMapper.xml` ，路径 resources/mapper/UserMapper.xml（可选测试）

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="com.sans.mapper.UserMapper">
   
       <sql id="selectSql">
           SELECT `user`.id,`user`.name,`user`.age,`user`.email
           FROM user
       </sql>
   
       <!-- ····· -->
   
       <!-- pagehelper 映射分页查询-->
       <select id="selectUserByPage2" resultType="user">
           <include refid="selectSql"></include>
           <where>
               <if test="age !=null">
                   age = #{age}
               </if>
               <if test="email !=null">
                   and email like '%${email}%'
               </if>
           </where>
       </select>
   
   </mapper>
   ```

5. 测试

   ```java
   // pagehelper分页
   @Test
   public void testSelectUserByPage2() {
   
       User u = new User();
       u.setAge(20);
       u.setEmail("test2");
       PageInfo<User> page = PageHelper.startPage(1,2).doSelectPageInfo(() ->{
           // 方法选择测试 (他们测试结果一致)
           // 1. 自定义xml
           mapper.selectUserByPage2(u);
           // 2. mp 内置方法
           // mapper.selectList(Wrappers.<User>query().eq("age",20).like("email","test2"));
       });
   
       page.getList().forEach(System.out :: println);
   
       System.out.println("===========");
   
       System.out.println("总行数=" + page.getTotal());
       System.out.println("总页数=" + page.getPages());
       System.out.println("每页行数=" + page.getPageSize());
   
       System.out.println("当前页=" + page.getPageNum());
       System.out.println("起始行数=" + page.getStartRow());
   
       System.out.println("是第一页=" + page.isIsFirstPage());
       System.out.println("是最后页=" + page.isIsLastPage());
   
       System.out.println("还有下一页=" + page.isHasNextPage());
       System.out.println("还有上一页=" + page.isHasPreviousPage());
   
       System.out.println("页码列表" + Arrays.toString(page.getNavigatepageNums()));
   }
   
   /*
   
   User(id=2, name=Jack, age=20, email=test2@baomidou.com)
   User(id=3, name=Jack, age=20, email=test2@baomidou.com)
   ===========
   总行数=13
   总页数=7
   每页行数=2
   当前页=1
   起始行数=1
   是第一页=true
   是最后页=false
   还有下一页=true
   还有上一页=false
   页码列表[1, 2, 3, 4, 5, 6, 7]
   
   */
   ```

**官方文档：**[MyBatis-Plus (baomidou.com)](https://mp.baomidou.com/guide/) 

#### 反向工程

官方在 3.5.1 以上和以下 分别 生成方式都不一样，因此做了两个示例

工程配置文档：[添加跳转](https://baomidou.com/pages/981406/#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE-datasourceconfig) 

##### 3.5.1之前

**步骤：**

1. 引入必要jar `freemarker`模板、`lombok`简化实体、`mybatis-plus-generator`生成核心

   ```xml
   <dependency>
       <groupId>org.freemarker</groupId>
       <artifactId>freemarker</artifactId>
       <version>2.3.31</version>
   </dependency>
   <dependency>
       <groupId>org.projectlombok</groupId>
       <artifactId>lombok</artifactId>
   </dependency>
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus-generator</artifactId>
       <version>3.4.1</version>
   </dependency>
   ```

   > 生成后可以直接删除 `freemarker`模板、`mybatis-plus-generator`生成核心

2. 反向工程启动类

   必要提示说明：

   - 数据源配置
   - 作者
   - 生成路径
   - 模组名（启动输入
   - 表名（启动输入

   ```java
   import com.baomidou.mybatisplus.annotation.FieldFill;
   import com.baomidou.mybatisplus.annotation.IdType;
   import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;
   import com.baomidou.mybatisplus.core.toolkit.StringPool;
   import com.baomidou.mybatisplus.core.toolkit.StringUtils;
   import com.baomidou.mybatisplus.generator.AutoGenerator;
   import com.baomidou.mybatisplus.generator.InjectionConfig;
   import com.baomidou.mybatisplus.generator.config.*;
   import com.baomidou.mybatisplus.generator.config.po.TableFill;
   import com.baomidou.mybatisplus.generator.config.po.TableInfo;
   import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
   import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
   
   import java.util.ArrayList;
   import java.util.List;
   import java.util.Scanner;
   
   public class MysqlGenerator {
   
       /**
        * <p>
        * 读取控制台内容
        * </p>
        */
       public static String scanner(String tip) {
           Scanner scanner = new Scanner(System.in);
           StringBuilder help = new StringBuilder();
           help.append("请输入" + tip + "：");
           System.out.println(help.toString());
           if (scanner.hasNext()) {
               String ipt = scanner.next();
               if (StringUtils.isNotBlank(ipt)) {
                   return ipt;
               }
           }
           throw new MybatisPlusException("请输入正确的" + tip + "！");
       }
   
       public static void main(String[] args) {
           // 代码生成器
           AutoGenerator mpg = new AutoGenerator();
   
           // 全局配置
           GlobalConfig gc = new GlobalConfig();
           String projectPath = System.getProperty("user.dir");
           /*
           指定工程名称
           指定作者
           *  */
           gc.setOutputDir(projectPath + "/NewsSys/src/main/java");
           gc.setAuthor("sasn");
           gc.setOpen(false);
           gc.setIdType(IdType.AUTO);//设置全局id自增
           gc.setBaseResultMap(true);//设置生成BaseResultMap
           // gc.setSwagger2(true); 实体属性 Swagger2 注解
           mpg.setGlobalConfig(gc);
   
           // 数据源配置
           /* 写自己的连接源 */
           DataSourceConfig dsc = new DataSourceConfig();
           dsc.setUrl("jdbc:mysql://localhost:3306/test?serverTimezone=UTC");
           // dsc.setSchemaName("public");
           dsc.setDriverName("com.mysql.jdbc.Driver");
           dsc.setUsername("root");
           dsc.setPassword("root");
           
           // 库数据 和 实体数据字段手动匹配配置
           dsc.setTypeConvert(new MySqlTypeConvert() {
               @Override
               public IColumnType processTypeConvert(@org.jetbrains.annotations.NotNull GlobalConfig globalConfig,
                                                     @org.jetbrains.annotations.NotNull String fieldType) {
                   // 比较库字段类型
                   if ("datetime".equals(fieldType)) {
                       // 满足则返回需要对应的实体类型
                       return DbColumnType.DATE;
                   }
                   if ("float".equals(fieldType)) {
                       return DbColumnType.BASE_DOUBLE;
                   }
                   switch (fieldType) {
                       case "text" :
                       case "mediumtext" :
                           return DbColumnType.STRING;
                       default:
                           break;
                   }
                   return super.processTypeConvert(globalConfig, fieldType);
               }
           }
           
           mpg.setDataSource(dsc);
   
           // 包配置
           /* 指定模块名称 */
           PackageConfig pc = new PackageConfig();
           pc.setModuleName(scanner("模块名"));
           pc.setParent("com.sans");
           mpg.setPackageInfo(pc);
   
           // 自定义配置
           InjectionConfig cfg = new InjectionConfig() {
               @Override
               public void initMap() {
                   // to do nothing
               }
           };
   
           // 如果模板引擎是 freemarker  从依赖包的 templates下查找模板
           String templatePath = "/templates/mapper.java.ftl";
           // 如果模板引擎是 velocity
           // String templatePath = "/templates/mapper.xml.vm";
   
           // 自定义输出配置
           List<FileOutConfig> focList = new ArrayList<>();
           // 自定义配置会被优先输出
           focList.add(new FileOutConfig(templatePath) {
               @Override
               public String outputFile(TableInfo tableInfo) {
                   // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！
                   return projectPath + "/src/main/resources/mapper/" + pc.getModuleName()
                           + "/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML;
               }
           });
           /*
           cfg.setFileCreate(new IFileCreate() {
               @Override
               public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {
                   // 判断自定义文件夹是否需要创建
                   checkDir("调用默认方法创建的目录，自定义目录用");
                   if (fileType == FileType.MAPPER) {
                       // 已经生成 mapper 文件判断存在，不想重新生成返回 false
                       return !new File(filePath).exists();
                   }
                   // 允许生成模板文件
                   return true;
               }
           });
           */
           cfg.setFileOutConfigList(focList);
           mpg.setCfg(cfg);
   
           // 配置模板
          // TemplateConfig templateConfig = new TemplateConfig();
   
           // 配置自定义输出模板
           //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别
           // templateConfig.setEntity("templates/entity2.java");
           // templateConfig.setService();
           // templateConfig.setController();
   
           //templateConfig.setXml(null);
          // mpg.setTemplate(templateConfig);
   
           // 策略配置
           StrategyConfig strategy = new StrategyConfig();
           strategy.setNaming(NamingStrategy.underline_to_camel);
           strategy.setColumnNaming(NamingStrategy.underline_to_camel);
   //        strategy.setSuperEntityClass("你自己的父类实体,没有就不用设置!");
           strategy.setEntityLombokModel(true);
           strategy.setRestControllerStyle(true);
           // 公共父类
   //        strategy.setSuperControllerClass("你自己的父类控制器,没有就不用设置!");
           // 写于父类中的公共字段
   //        strategy.setSuperEntityColumns("id");
           strategy.setEnableSqlFilter(false);//开启支持输入正则表达式
           strategy.setInclude(scanner("表名，多个英文逗号分割").split(","));
           strategy.setControllerMappingHyphenStyle(true);
           strategy.setTablePrefix(pc.getModuleName() + "_");
   
           //设置生成自动填充注解的表字段
           ArrayList<TableFill> list = new ArrayList<>();
           list.add(new TableFill("update_date", FieldFill.INSERT_UPDATE));
           list.add(new TableFill("create_date", FieldFill.INSERT));
           list.add(new TableFill("del_flag", FieldFill.INSERT));
           strategy.setTableFillList(list);
           strategy.setLogicDeleteFieldName("del_flag");//设置生成逻辑删除注解对应表字段名
           mpg.setStrategy(strategy);
           mpg.setTemplateEngine(new FreemarkerTemplateEngine());
           mpg.execute();
       }
   }
   ```

##### 3.5.1之后

**步骤：**

1. 引入必要jar `freemarker`模板、`annotations`配置注解应用、`mybatis-plus-generator`生成核心

   ```xml
   <dependency>
       <groupId>com.baomidou</groupId>
       <artifactId>mybatis-plus-generator</artifactId>
       <version>3.5.2</version>
   </dependency>
   <dependency>
       <groupId>org.freemarker</groupId>
       <artifactId>freemarker</artifactId>
       <version>2.3.31</version>
   </dependency>
   <dependency>
       <groupId>org.jetbrains</groupId>
       <artifactId>annotations</artifactId>
       <version>16.0.1</version>
   </dependency>
   ```

   > 生成后可以直接删除 `freemarker`模板、`mybatis-plus-generator`生成核心

2. 反向工程启动类 

   > 注意参数的填充

   ```java
   import com.baomidou.mybatisplus.generator.FastAutoGenerator;
   import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
   import com.baomidou.mybatisplus.generator.config.GlobalConfig;
   import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;
   import com.baomidou.mybatisplus.generator.config.querys.MySqlQuery;
   import com.baomidou.mybatisplus.generator.config.rules.DbColumnType;
   import com.baomidou.mybatisplus.generator.config.rules.IColumnType;
   import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;
   
   public class BuilderApplication {
   
       public static void main(String[] args) {
   
           String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";
           String username = "root";
           String passwoed = "root";
           String baomidou = "柏竹";
           String packagePath = "com.sans";
           String generatePath = "D:\\Code\\Java\\Drill\\Guangdong embedded\\01 Study\\JavaEE\\220607SpringCloud\\220607WebService\\220607WebService\\Restful-Server\\src\\main\\java";
   
           DataSourceConfig.Builder dataSourceBuilder = new DataSourceConfig.Builder(url, username, passwoed)
                   .dbQuery(new MySqlQuery())
                   .typeConvert(new MySqlTypeConvert() {
                       @Override
                       public IColumnType processTypeConvert(@org.jetbrains.annotations.NotNull GlobalConfig globalConfig,
                                                             @org.jetbrains.annotations.NotNull String fieldType) {
                           // 比较库字段类型
                           if ("datetime".equals(fieldType)) {
                               // 满足则返回需要对应的实体类型
                               return DbColumnType.DATE;
                           }
                           return super.processTypeConvert(globalConfig, fieldType);
                       }
                   });
   
   
           /**
            * 配置文档：https://baomidou.com/pages/981406/
            */
           FastAutoGenerator.create(dataSourceBuilder)
                   // 全局配置
                   .globalConfig(builder -> {
                       builder.author(baomidou)
   //                            .enableSwagger()
                               .disableOpenDir()
                               .fileOverride()
                               .outputDir(generatePath); // 指定输出目录
                   })
                   // 包配置
                   .packageConfig(builder -> {
                       builder.parent(packagePath); // 设置父包名
   //                            .moduleName(moduleName); // 设置父包模块名
   //                            .pathInfo(Collections.singletonMap(OutputFile.mapper, XMLPath)); // 设置mapperXml生成路径
                   })
                   // 策略配置
                   .strategyConfig(builder -> {
                       // 指定表
                       builder.addInclude("book") // 设置需要生成的表名
   //                            .addInclude("news_detail")
                               .enableCapitalMode()
                               // Entity 策略配置
                               // 逻辑删除/乐观锁 字段
                               .entityBuilder()
                               .versionColumnName("version")
                               .versionPropertyName("version")
                               .logicDeleteColumnName("deleted")
                           	/.enableLombok() // 启动 lombok 模型
                               .mapperBuilder()
                               .enableBaseResultMap()
                               .enableMapperAnnotation()
                       ;
                   })
                   .templateEngine(new FreemarkerTemplateEngine())  // 使用Freemarker引擎模板，默认的是Velocity引擎模板
                   .execute();
       }
   }
   ```
   

### JSON整合

SpringBoot 自带有 jackson 和 gson  , 一般JSON操作是通过 `ObjectMapper`对象 进行操作(工具类) 

> SpringBoot 一般情况是使用自动注入形式调用 `ObjectMapper`对象

#### 对象>JSON

```java
User user = new User();
String userJson = new ObjectMapper().writeValueAsString(user);
//...
```

#### JSON>对象

```java
// 单对象
String json = "{name:'Sans', age:22}";
User user = new ObjectMapper().readValue(josn, User.class);
// 数组
String jsonArrayStr = "[{\"id\":\"123\",\"name\":\"张三\"},{\"id\":\"456\",\"name\":\"李四\"}]";
List<Person> personList = objectMapper.readValue(jsonArrayStr, new TypeReference<List<Person>>() {});
```

#### 自定义工具类

```java
public class JsonUtil {

    public static final ObjectMapper objectMapper = new ObjectMapper();

    static {
        //忽略字段不匹配错误
 objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    /**
     * 创建 ObjectNode
     * @return
     */
    public static ObjectNode createJson() {
        return objectMapper.createObjectNode();
    }

    /**
     * 字符串转 java bean
     * @param json
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T string2Bean(String json, Class<T> clazz){
        T t = null;
        try {
            t = objectMapper.readValue(json,clazz);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return t;
    }

    /**
     * 字符串转 Map
     * @param json
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> Map<String,Object> string2Map(String json, Class<T> clazz){
        Map<String,Object> map = null;
        try {
            map = objectMapper.readValue(json, new TypeReference<Map<String,Object>>() {});
        } catch (JsonProcessingException e) {
            map = Collections.emptyMap();
            e.printStackTrace();
        }
        return map;
    }

    /**
     * 字符串转 List<Bean>
     * @param json
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> List<T> string2BeanList(String json, Class<T> clazz){
        List<T> t = null;
        try {
            t = objectMapper.readValue(json, new TypeReference<List<T>>() {});
        } catch (JsonProcessingException e) {
            t = Collections.emptyList();
            e.printStackTrace();
        }
        return t;
    }

    /**
     * 字符串转 Bean[]
     * @param json
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T[] string2BeanArray(String json, Class<T> clazz){
        T[] t = null;
        try {
            t = objectMapper.readValue(json, new TypeReference<T[]>() {});
        } catch (JsonProcessingException e) {
            t = (T[])new Object[0];
            e.printStackTrace();
        }
        return t;
    }

    /**
     * 字符串转 JsonNode
     * @param json
     * @return
     */
    public static JsonNode string2Json(String json) {
        JsonNode jsonNode = null;
        try {
            jsonNode = objectMapper.readTree(json);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return jsonNode;
    }

    /**
     * java bean 或者 Map 或者 JsonNode 转字符串
     * @param o
     * @return
     */
    public static String object2String(Object o) {
        String json = null;
        try {
            json = objectMapper.writeValueAsString(o);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return json;
    }

    /**
     * java bean 或者 Map 或者 JsonNode 转 JsonNode
     * @param o
     * @return
     */
    public static JsonNode object2Json(Object o) {
        JsonNode jsonNode = null;
        try {
            String jsonString = objectMapper.writeValueAsString(o);
            jsonNode = objectMapper.readTree(jsonString);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return jsonNode;
    }

    /**
     * jsonNode 转 JsonNode
     * @param jsonNode
     * @return
     */
    public static <T> T json2Bean(JsonNode jsonNode, Class<T> clazz) {
        String json = jsonNode.toString();
        return string2Bean(json, clazz);
    }
}
```

**应用实例**

```java
// 数组
public static void main(String[] args) {
    ObjectNode person = objectMapper.createObjectNode();
    person.put("id","1101");
    person.put("name","张三");
    person.put("age",35);
    person.put("sex","男");

    List<ObjectNode> children = new ArrayList<>(1);
    ObjectNode child = objectMapper.createObjectNode();
    child.put("id","1102");
    child.put("name","张小三");
    child.put("age",12);
    child.put("sex","男");

    children.add(child);

    person.putArray("children").addAll(children);

    System.out.println(person.toPrettyString());
}
```

## 部署

### Jar打包

大致流程

1. jdk安装 , 并配置
2. Maven打包项目 , 上传服务器
3. 运行jar项目

> SpringBoot内置集成Tomcat , 无需安装即可应用

**项目打包**

Maven -> 双击package , 加载完会在 /target(缓存路径) 上看到 .jar 文件 , 在Liunx系统里运行即可

**运行jar包项目**

```shell
nohup java -jar shop-0.0.1-SNAPSHOT.jar > logName.log 2>&1 &
```

**指令说明**

- ==nohup java -jar shop-0.0.1-SNAPSHOT.jar== 运行项目 , 不挂断运行
- ==Log.log 2>&1== 表示将`stdout`和`stderr`合并后重定向到`log.file`

> 运行后可以看到 一串数值 , 可通过 ==jps==指令 进行查看进程

**关闭进程 :** 

```shell
# 查指定端口 (查8080)
netstat -nlp|grep 8080
# 确定端口的 PID
kill -9 {PID}
```

### Docker打包/群辉挂载

0. jar打包

1. 创建 dorderfile.txt (编辑配置文件) , 保存后取出后缀 .txt
   ```dockerfile
   # Docker image for springboot file run
   # VERSION 0.0.1
   # Author: 
   # 基础镜像使用java
   FROM openjdk:8
   # 作者
   MAINTAINER Sans
   # VOLUME 指定了临时文件目录为/tmp。
   # 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp
   VOLUME /tmp 
   # 将jar包添加到容器中并更名为xx.jar (demo.jar -> test.jar)
   ADD demo.jar test.jar 
   # 运行jar包
   RUN bash -c 'touch /test.jar'
   ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/test.jar"]
   ```

2. 执行镜像打包 (在含有 dockerfild 和 xx.jar 执行以下文件) 
   ```docker
   sudo docker build . -t demo-name:v1.0
   ```

3. 打开docker , 镜像加载即可 (配置按照默认)

4. 反向代理 , 控制面板 -> 登录门户 -> 高级 -> 反向代理服务器
   新增 来源 *:端口 ; 目的 locakhost:本地端口

5. 外部访问即可

### SSL域名认证

SSL能够将该网站变为更安全的网站 , HTTPS独有的协议 

阿里云申请后 : 下载`JKS` 证书类型(里面有 key和password 两个文件)

key放到 `resources`目录 即可

**application文件配置** 

```properties
# 域名 SSL配置
server.ssl.key-store=classpath:8840811_bozhu.free.svipss.top.jks
server.ssl.key-store-password=xxxx
server.ssl.key-store-type=JKS
```

> server.ssl.key-store : key文件的全名称
> server.ssl.key-store-password : 第二个文件夹的内容粘贴出来
> server.ssl.key-store-type : 认证类型 JKS

直接访问https接口 , 也可以设置重定向为https

### SSH

先连接OpenWrt 作为代理主机进行操作

OpenWrt SSH访问在

==系统 -> 管理权 -> Dropbear 实例== : 启动网关端口...



群辉SSH 先访问OpenWrt作为代理进行内网访问群辉SSHComponent
