---
title: Java三大特性
date: 2020-02-18 00:00:00
permalink: /backend/39ibdm
categories:
  - 后端
  - Java基础
tags:
  - Java
author: 柏竹
---

# Java三大特性

## 继承

子类可以继承父类原有的 **属性** 和 **方法**，也可以增加父类没有的属性和方法，还可以重写父类中的某些方法，继承应用的关键字：`extends`

**继承特性说明：**

- 继承关系信息的传递
- 降低功能和属性复用
- 父类方法重写以及修饰权限的访问
- 多父类的继承
- 继承关系中 子类只能继承一个父类，不能继承多个父类
- 子类可以覆盖父类方法，而且还可以覆盖父类的属性

### 方法重写Oveeride

方法重写在子父类中发生的，子类修改父类方法，名字必须相同返回类型也必须一致

**注意：**

- 父类用 `final`/`static` 关键字声明的方法不能被子类进行重写
- 构造方法不能被重写

**示例：**

```java
public class Demo {
    public static void main(String[] args) {
        
        Animals ton = new Dog("Dog(狗)");
        System.out.println(ton.move());
        
        Animals Jak = new Rabbit("Rabbit(兔子)");
        System.out.println(Jak.move());
    
        Animals Yin = new Eagle("Eagle(鹰)");
        System.out.println(Yin.move());
        
    }
}

//动物类
class Animals {
    String type;
    public Animals(String type){
        this.type = type;
    }
    //移动的方法
    public String move(){
        return(type+"的移动方式：");
    }
}

//狗类 继承 动物类
class Dog extends Animals{
    public Dog(String type) {
        super(type);
    }
    
    @Override
    //重写移动方法
    public String move(){
        return (super.move()+"跑");
    }
}

//兔子类 继承 动物类
class Rabbit extends Animals{
    public Rabbit(String type) {
        super(type);
    }
    
    @Override
    //重写移动方法
    public String move(){
        return (super.move()+"跳");
    }
}

//鹰类 继承 动物类
class Eagle extends Animals{
    public Eagle(String type) {
        super(type);
    }
    
    @Override
    //重写移动方法
    public String move(){
        return (super.move()+"飞翔");
    }
}

/* 运行结果

Dog(狗)的移动方式：跑
Rabbit(兔子)的移动方式：跳
Eagle(鹰)的移动方式：飞翔

*/
```



### Object类

Object类是所有类的父类，是最顶层的类，定义类时可省略 `extends Object` 关键字 ，任何类都可以重写Object类中的方法

**Object方法**

<font color = #05ffdc>Object.getClass() </font> 返回对象执行时的Class实例

<font color = #05ffdc>Object.toString() </font> 以字符串形式返回对象

<font color = #05ffdc>Object.equals(Object val) </font> 比较两对象的引用是否相等（内容）

> equals（）方法比较内容，`==` 比较对象引用的地址

以下代码 Object方法测试

```java
public class Demo{
    public static void main(String[] args) {
        Object[] arr = new Object[4];
        arr[0] = new Object();
        arr[1] = new String("字符串");
        arr[2] = new Demo();
        arr[3] = new Integer(12);
        
        //getClass()方法
        System.out.println("---------getClass()方法--------");
        for(Object tmp : arr){
            System.out.println(tmp.getClass()); }
        System.out.println();
    
        //toString()方法
        System.out.println("---------toString()方法--------");
        for(Object tmp : arr){
            System.out.println(tmp.toString()); }
        System.out.println("-----------------");
        for(Object tmp : arr){
            System.out.println(tmp); }
        System.out.println();
    
        //equals()方法
        Object no1 = new Integer(12);
        Object no2 = new String("12");
        Object no3 = new Integer(12);
        System.out.println("---------equals()方法--------");
        System.out.println(no1.equals(12));
        System.out.println(no1.equals(no3));
        System.out.println(no1.equals(arr[3]));
        System.out.println(no1.equals(no2));
    }
}
```

运行结果

```text
---------getClass()方法--------
class java.lang.Object
class java.lang.String
class Demo
class java.lang.Integer

---------toString()方法--------
java.lang.Object@10f87f48
字符串
Demo@b4c966a
12
-----------------
java.lang.Object@10f87f48
字符串
Demo@b4c966a
12

---------equals()方法--------
true
true
true
false
```

### instanceof关键字

`instanceof`关键字 是判断 指定子类是否继承该父类

```java
Boolean bool = A instanceof B
// A 继承 B =》bool = true 
// A 不继承 B =》bool = false
```

**示例：**

```java
class A{ }

class B extends A{ }

class C extends B implements E{ }

interface E{ }

public class Demo {
    public static void main(String[] ars) {
        C c = new C();
        System.out.println("c是否继承A父类?"+(c instanceof A));
        
        System.out.println("c是否继承B父类?"+(c instanceof B));
        
        System.out.println("c是否调用E接口?"+(c instanceof E));
        
        B b = new B();
        System.out.println("\nb是否继承C父类?"+(b instanceof C));
        
        System.out.println("b是否继承A父类?"+(b instanceof A));
    }
}

/* 运行结果

c是否继承A父类?true
c是否继承B父类?true
c是否调用E接口?true

b是否继承C父类?false
b是否继承A父类?true

*/
```

## 多态

多态可以根据不同类在同一变量，同一方法，执行结果不同的作用

### 对象类型的转换

#### 向上转型

向上转型是子类对象赋值给父类类型的变量 （子类 → 父类）

```java
class A {}
class B extends A{}
// 测试主方法
main(){
   A b = new B();
}
```

#### 向下转型

向下转型是将比较抽象的类转换为较具体的类（父类 → 子类）

> 转换的前提继承父类的子类必须是它本身

```java
class A {}
class B extends A{}
// 测试主方法
main(){
   A b = new B();
    //向下转型
   B b = (B) b;
}
```

**注意：**

> 编译 参考父类是否存在指定成员
> **成员方法：**
>
>  - 编译时，参考父类是否存在该方法，有则成功，没有则失败
>  - 运行时，参考子类重写的方法
>
> **成员变量：**
>
>  - 编译时，参考父类是否有该变量，有则成功，没有则失败
>  - 运行时，运行出的结果是父类的成员变量

**实例：**

```java
public class Demo {
    public static void main(String[] args) {
        
        A a  = new A();
        System.out.println(a.a); //4
        System.out.println(a.test());  //BB
    
        System.out.println();
        
        // 向上转型输出情况
        A b = new B();
        System.out.println(b.a); //4
        System.out.println(b.test());  //BB
    
        System.out.println();
        
        // 向下转型输出情况
        B b1 = (B)b;
        System.out.println(b1.a); //5
        System.out.println(b1.test()); //BB
        
    }
}

class A{
    int a = 4;
    public String test(){
        return "AA";
    }
}
class B extends A{
    int a = 5;
    @Override
    public String test() {
        return "BB";
    }
}

/* 运行结果

4
AA

4
BB

5
BB

*/
```

### 方法重载Overload

方法重载是在同一个类中允许多个同名方法，只要方法参数的形参不同即可！

**满足不同的条件：**

- 参数个数的不同
- 参数顺序的不同
- 参数类型的不同
- `...`定义不定长的参数个数

**示例：**

```java
public class Demo {
    public static void main(String[] args) {
        Demo d = new Demo();
        long a =1;
        
        d.method(1);
        d.method(1,2);
        d.method(1,a);
        d.method(a,1);
        d.method(1,2,3,4,5,6,7,8);
        d.method(a,2,3,4,5,6,7,8);
    }
    
    public void method(int a){
        System.out.println("调用了method( int )的方法");
    }
    
    //参数个数的不同
    public void method(int a,int b){
        System.out.println("调用了method( int , int )的方法");
    }
    
    //参数类型的不同
    public void method(int a,long b){
        System.out.println("调用了method( int , long )的方法");
    }
    
    //参数顺序的不同
    public void method(long a,int b){
        System.out.println("调用了method( long , int )的方法");
    }
    
    //不定长度参数方法
    public void method(int... a){
        System.out.println("调用了method(int...)的方法");
        for (int tmp : a){
            System.out.print(tmp+"\t"); }
        System.out.println();
    }
    
    public void method(long b, int... a){
        System.out.println("调用了method(long,int...)的方法");
        for (int tmp : a){
            System.out.print(tmp+"\t"); }
    }
   
}

/* 运行结果

调用了method( int )的方法
调用了method( int , int )的方法
调用了method( int , long )的方法
调用了method( long , int )的方法
调用了method(int...)的方法
1	2	3	4	5	6	7	8	
调用了method(long,int...)的方法
2	3	4	5	6	7	8	

*/
```

## 封装

封装是将类的某些信息隐藏在类的内部，不许外部直接访问，只能通过类提供的方法实现隐藏细节，对外提供访问，便于使用者调用

**特点：**

- 避免外部类直接访问
- 隐藏实现细节
- 提供接口外部访问
- 提高代码的复用率
- 封装的属性私有
- `private` 修饰的类属性，访问需要通过封装的方法进行访问类的属性

> 外部不能通过 ==类.成员属性== 进行访问 `private` 修饰的属性。如果应用需要通过 **方法返回** 进行使用

## 抽象类

抽象类 一般定义在父类，用来进行 **继承和多态** 的处理，该抽象类不能被 new实例化，需要子类具体化

**特点：**

- 抽象方法和抽象类 都是需要 `abstract` 修饰的
- 抽象类不能被 new实例化
- 只有被子类继承才有存在的意义

定义抽象类 的关键字 `abstract`

```java
public abstract class Text {	}
```

### 抽象方法

抽象方法没有方法体，本身是没有意义，需要被继承，子类必须重写且具体化重写的方法

**特点：**

- 抽象方法只能存在于该类是抽象类的情况
- 抽象方法存在的意义是被 子类重写

```java
public abstract class Text {
	abstract void textAbstract();
}
```

以下代码 抽象类和方法的使用

```java
public class Demo {
    public static void main(String[] args) {
        Teachers Tom = new Englishteachers();
        Teachers Jak = new Mathteachers();
//        Teachers Tea = new Teachers();
        
        Tom.teaching();
        Jak.teaching();
    }
}

//教师抽象类
abstract class Teachers {
    //讲课抽象方法
    public abstract void teaching();
}

//英语老师 继承 教师抽象类
class Englishteachers extends Teachers {
    @Override
    //重写讲课方法
    public void teaching(){
        System.out.println("英语老师，讲课");
    }
}

//数学老师 继承 教师抽象类
class Mathteachers extends Teachers {
    @Override
    //重写讲课方法
    public void teaching(){
        System.out.println("数学老师，讲课");
    }
}

/* 运行结果

英语老师，讲课
数学老师，讲课

*/
```

## 接口

接口是抽象类的延伸，能批量设置部分子类独有方法

**特点：**

- 修饰符默认为 `public`
- 定义的变量 只能是 常量
- 可以继承多个父接口，但类不能 (接口继承使用`extends` 关键字)
- 接口没有构造方法
- 子接口可以重写父接口的 常量和方法

定义接口 的关键字 `interface`

```java
public interface Test {
    void run(); 
}
```

**接口 继承与多继承**

子接口被调用时，该子接口的父接口全部方法都要继承，都要调用

一个类可以实现多个继承接口，在interface关键字后面逗号分隔即可

**示例：**

```java
interface DrawInterface {// 绘制接口
    public void draw();
}

interface Ddc extends DrawInterface{
    public void cs();
}

interface Ddcb {
    public void csb();
}

public class Demo {
    public static void main(String[] args) {
        DrawInterface d = new Qua();
        //调用重写接口方法
        d.draw();
    
        System.out.println("\n重新测试：");
        //实例化类本身
        Qua q = new Qua();
        //调用类本身的方法
        q.benshen();
        //调用重写接口方法
        q.draw();
        System.out.println();
        
        DrawInterface d2 = new Square();
        d2.draw();
        System.out.println();
        
        
        Ddc d3 = new Triangle();
        d3.draw();
        d3.cs();
        
        //实例对象本身调用接口方法
        Triangle t = new Triangle();
        t.csb();
    }
}

//三角形类
class Triangle implements Ddc ,Ddcb{    //实现多接口继承
    
    @Override
    public void draw() {
        System.out.println("绘制三角形");
    }
    
    @Override
    public void cs() {
        System.out.println("测试继承");
    }
    
    @Override
    public void csb() {
        System.out.println("测试继承2");
    }
}

//四边形类
class Qua implements DrawInterface {
    @Override
    public void draw(){
        System.out.println("绘制四边形");
    }
    
    public void benshen(){
        System.out.println("我是四边形");
    }
}

//正方形类 继承 四边形
class Square extends Qua implements DrawInterface {
    
    @Override
    public void draw() {
        System.out.println("绘制正方形");
    }
    
}

/* 运行结果

绘制四边形

重新测试：
我是四边形
绘制四边形

绘制正方形

绘制三角形
测试继承
测试继承2

*/
```

### 接口和抽象类的区别

1. **实现方式**
   抽象类：被子类继承
   接口：被类实现
2. **方法形式**
   抽象类：可声明 抽象/非抽象 方法
   接口：只能声明抽象方法
3. **声明变量**
   抽象类：成员变量
   接口：只能是公共的静态常量
4. **类继承&实现形式**
   抽象类： 一个类只能继承一个父类
   接口：一个类可实现多个接口
5. **静态方法**
   抽象类： 允许出现静态方法
   接口：不允许存在静态方法

   > PS：静态方法不能被子类重写，因此接口中不能声明静态方法
6. **构造方法**
   抽象类： 可以有构造方法
   接口：没有构造方法

## 三大特性的总结

**封装**：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式

**继承**：子类会自动拥有父类所有可继承的属性和方法

**多态**：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义



