---
title: XML&JSON
date: 2020-02-18 00:00:00
permalink: /backend/lipl8p
categories:
  - 后端开发
  - 编程语言
  - Java
tags:
  - Java
  - 数据格式
  - 进阶实战
  - 教程
author: 柏竹
---

# XML&JSON

## XML

XML 可拓展标志语言，Java实现需要导包jar，[点击链接](https://wwe.lanzous.com/i8D8Emb64be)

- 平台无关性，是门独立的标记语言
- 自我描述
- 网络数据传输
- 数据存储
- 配置文件

### XML文件

`.XML文件` 文件是保存 XML数据的方式。它可有其他形式。但XML语言不能理解成XML文件

### XML语法

#### 文档声明

```XML
<?xml version="1.0" encoding="UTF-8"?>
```

版本，编码类型

#### 标记

**开始标记** : <标记名称>

**结束标记** : </标记名称>

**标记名称** : 自定义名称

必须遵循以下命名规则：

1. 名称可以含字母、数字以及其他的字
2. 名称不能以数字或者标点符号开始
3. 名称不能以字符 “xml”（或者 XML、Xml）开始
4. 名称不能包含空格，不能包含冒号（:）
5. 名称区分大小写

**标记内容** : 开始标记与结束标记之间 ,是标记的内容

```xml
<name>戴佳伟</name>
<age>23</age>
```

#### 嵌套标记

```xml
正例:
<person>
	<name>戴佳伟</name>
	<age>23</age>
</person>
反例:
<person>
	<name>戴佳伟<age></name>
	23</age>
</person>
```

#### 标记属性

标记中的属性, 在标记开始时 描述, 由属 性名 和 属性值 组成

```xml
正例:
<persons>
	<person id = "001" groupid = "1">
		<name>戴佳伟</name>
		<age>23</age>
	</person>
	<person  id = "002" groupid = "2">
		<name>陈二狗</name>
		<age>24</age>
	</person>
</persons>
```

#### 注释

注释不能写在文档文档声明前

```xml
<!--注释内容-->
```

#### 进阶CDATA

用于过滤内容。在解析文本数据时 `<` 和 `&` 字符在XML非法的，会产生错误，因解析器误认为 `<` 是新的元数开始 ；`&` 是字符实体的开始

某些语言的文本，可能会存在大量 `<` 和 `&` 字符。因此可以将脚本代码定义为CATA

```xml
<!--
CDATA 部分中的所有内容都会被解析器忽略。
CDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束
-->
<mane><![CDATA[你<a></a>好]]></mane>
```

### XML解析方式

#### SAX解析

**说明：**

- 逐行解析 单向
- 事件驱动机制。当每解析到 开始/结束/内容/属性 时，触发事件
- 可进行发生时处理

**优点：**

- 可立即开始，无需等待数据处理
- 逐行加载，省空间
- 满足条件可立即停止解析

**缺点：**

- 单向解析，无法定位文档层次，读完一行释放一行！！
- 只能得知自己的节点的 父/子 关系
- 只读，无法修改

#### DOM解析

**说明：**

- 解析需要加载整个 文档 和 内存
- 有文档树模型
- 可操作文档树进行 获取、修改、删除等。。。

**优点：**

- 文档在内存中加载, 可对 数据 和 结构 做出更改
- 双向访问

**缺点：**

- 耗费内存资源较大

#### JDOM解析

Java特定文档模型，比DOM实现快

**优点：**

- 使用 具体类 而非接口，简化DOM的API
- 复原Java集合类，使用方便

**缺点：**

- 灵活性差
- 性能一般

#### DOM4J解析

DOM4J是JDOM的一种智能分支。功能强大！

<a href=#G3>点击代码示例</a><a id="C3" href=#>*</a> （DOM4J-XPATH网络解析）

**路径表示式**

> `/` ：从根节点开始查找
> `//` ：从发起查找的节点位置，查找子节点
> `.` ：找到当前节点
> `..` ：查找父节点
> `@` ：属性筛选
> 	[@属性名 = 'value']
> 	[@属性名 > 'value']
> 	[@属性名 < 'value']
> 	[@属性名 != 'value']

```xml
<persons>
	<person id = "001" groupid = "1">
		<name>戴佳伟</name>
		<age>23</age>
	</person>
	<person  id = "002" groupid = "2">
		<name>陈二狗</name>
		<age>24</age>
	</person>
</persons>

<!-- 
人名：
persons : //person//name
指定id
persons : //person[@id = '002']//name
-->
```

### XML对象类型

#### 文档对象

**Document接口** 用于文本容器。文档加载到内存的整个 XML文档

**常用方法** （更多自行API）

| 返回         | 方法                                                       | 说明                           |
| ------------ | ---------------------------------------------------------- | ------------------------------ |
| Element      | <font color = #05ffdc>addElement(String name)</font>       | 添加 根节点 并返回             |
| Element      | <font color = #05ffdc>getRootElement()</font>              | 获取 根节点                    |
| Element      | <font color = #05ffdc>getDafultRootElement()</font>        | 获取 树的根元素                |
| Element[]    | <font color = #05ffdc>getRootElements()</font>             | 获取 定义的所有根元素          |
| int          | <font color = #05ffdc>getLength()</font>                   | 获取 文档内容字符数            |
| String       | <font color = #05ffdc>getText(int off , int len)</font>    | 获取 指定文本范围              |
| Object       | <font color = #05ffdc>getProperty(Object key)</font>       | 获取 与文档关联的属性          |
| List`<Node>` | <font color = #05ffdc>selectNodes(String name)</font>      | 获取 指定路径的所有 name节点   |
| String       | <font color = #05ffdc>selectSingleNode(String name)</font> | 获取 指定路径的第一个 name节点 |

#### 元素对象

**Element接口** 用于XML文档单个节点的捕捉。

**常用方法** （更多自行API）

| 返回            | 方法                                                         | 说明                    |
| --------------- | ------------------------------------------------------------ | ----------------------- |
| void            | <font color = #05ffdc>addAttribute(String name , String value)</font> | 添加属性                |
| Element         | <font color = #05ffdc>addElement(String sonName)</font>      | 添加 子节点并返回       |
| String          | <font color = #05ffdc>attributeValue(String name)</font>     | 获取 节点的属性值       |
| String          | <font color = #05ffdc>getName()</font>                       | 获取 节点名称           |
| String          | <font color = #05ffdc>getText()</font>                       | 获取 节点内容           |
| Element         | <font color = #05ffdc>getParentElement()</font>              | 获取 父元素             |
| String          | <font color = #05ffdc>elementText(String sonName)</font>     | 获取 子节点的内容       |
| Element         | <font color = #05ffdc>element(String name)</font>            | 获取 匹配名称的第一节点 |
| List`<Element>` | <font color = #05ffdc>elements()</font>                      | 获取 所有的子节点对象   |
| String          | <font color = #05ffdc>setText()</font>                       | 更改 节点内容           |

<a href=#G1>点击代码示例</a><a id="C1" href=#>*</a> （XML本地解析）

<a href=#G2>点击代码示例</a><a id="C2" href=#>*</a> （XML网络解析）

## JSON

JSON（JavaScript Object Notation），是轻量级的数据交换格式

### 对象格式

- 一个对象，由大括号包括表示，括号中包含属性（通过键值描述对象）
- 每对 **键与值** 要用 `:`冒号连接；每对 **键值** 要用 `,`逗号分隔
- 每对 **键值的键** 都要用 `"`引号引住（Java解析需要）
- 每对 **键值的值** 使用的是Object类型（任何类型）
  如果值中有数组形式需要 `[]`方括号括住元素

```json
{
    "name":"陈二狗",
    "age":"23",
    "friend":["王二","张三","李四",{
       "name":"黑马老师",
        "info":"带我们走向胜利！"
    }],
    "equipment":{
        "name":"武士刀",
        "length":"60cm"
    }
}
```

### JSON解析

导包链接进不了可以试试这个[点击链接](https://wwe.lanzous.com/iWByFmb64eh) （包含 谷歌 和 阿里 ）

#### Gson

Java实现需要导包jar，[点击链接](https://github.com/google/gson)

```java
//假如有个 `People类` ,有`name` , `age` 2个属性
People people = new People("陈二狗" , "23");

//序列化
Gson gson = new Gson();
String json = gson.toJson(people); 	//可参数任意
/* 序列化结果 的json
{
	"name":"陈二狗",
	"age":"23"
}
*/

//反序列化
People people = gson.fromJson(json , People.class);
```

<a href=#G4>点击代码示例</a><a id="C4" href=#>*</a> （Gson序列化与反序列化）

#### FastJson

Java实现需要导包jar，[点击链接](https://github.com/alibaba/fastjson)

```java
//假如有个 `People类` ,有`name` , `age` 2个属性
People people = new People("陈二狗" , "23");

//序列化
String json = JSON.toJSONString(people);	//可参数任意
/* 序列化结果 的json
{
	"name":"陈二狗",
	"age":"23"
}
*/

//反序列化
People people = JSON.parseObject(json , People.class);
```

<a href=#G5>点击代码示例</a><a id="C5" href=#>*</a> （FastJson序列化与反序列化）

## 代码索引

### XML解析

（<a href=#C1>返回</a><a id="G1" href=#>*</a>）

```java
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.List;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-02-27 21:50
 * @Modified_By:
 * @Project： 解析本地XML文件
 */

public class Demo {
    public static void main(String[] args) throws IOException, DocumentException {
        
        //1.    获取流（项目跟路径）
        FileInputStream fis = new FileInputStream("Demo.xml");
        //2.    创建XML读取对象
        SAXReader sr = new SAXReader();
        //3.    读取并得到对象
        Document doc = sr.read(fis);
        //4.    通过文档获取根元素
        Element root = doc.getRootElement();
        //5.    解析根元素
        
        System.out.println(root.attributeValue("id"));
        
        List<Element> es = root.elements();
        for (int i = 0 ; i < 2 ; i++) {
            Element people = es.get(i);
            System.out.println("====================");
            System.out.println("name  : " + people.elementText("name"));
            System.out.println("age  : " + people.elementText("age"));
            System.out.println("====================");
        }
        
        fis.close();
    }
}

/*
异灵术狗贼二人组
====================
name  : 戴佳伟
age  : 23
====================
====================
name  : 陈二狗
age  : 24
====================
*/
```
**Demo.xml文件** （根项目路径）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<peoples id="异灵术狗贼二人组">
    <people>
        <name>戴佳伟</name>
        <age>23</age>
    </people>
    <people>
        <name>陈二狗</name>
        <age>24</age>
    </people>
</peoples>
```

### XML网络解析

（<a href=#C2>返回</a><a id="G2" href=#>*</a>）

```java
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.Scanner;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-02-28 8:56
 * @Modified_By:
 * @Project： 解析网络文件
 */
public class Demo2 {
    public static void main(String[] args) throws IOException, DocumentException, InterruptedException {
        System.out.println("手机信息查询");
        System.out.print("输查询的手机号码 ： ");
        String phone = new Scanner(System.in).nextLine();
        URL url = new URL("http://apis.juhe.cn/mobile/get? phone="+phone+"&dtype=xml&key=9f3923e8f87f1ea50ed4ec8c39cc9253");
        URLConnection conn = url.openConnection();
        InputStream is = conn.getInputStream();
        SAXReader sr = new SAXReader();
        Document doc = sr.read(is);
        Element root = doc.getRootElement();
        Element code = root.element("resultcode");
        Thread.sleep(1000);
        if (code.getText().equals("200")){
            Element result = root.element("result");
            String province = result.element("province").getText();
            String city = result.elementText("city");
            String postCode = result.elementText("zip");
            String supplier = result.elementText("company");
            System.out.println("==============");
            if (province.equals(city)){
                System.out.println("归属地 ： " + province);
            }else{
                System.out.println("归属地 ： " + province +" "+city);
            }
            System.out.println("邮政编号 ： "+ postCode);
            System.out.println("运营商 ： "+ supplier);
            System.out.println("==============");
        }else{
            System.out.println("请从新输入号码 ！ ");
        }
        
        is.close();
    }
}

/*
手机信息查询
输查询的手机号码 ： 17155943925
==============
归属地 ： 福建 莆田
邮政编号 ： 351100
运营商 ： 国美极信
==============
*/
```
**xml网络文档**

```xml
<root nighteye="disabled">
	<resultcode>200</resultcode>
	<reason>Return Successd!</reason>
	<result>
		<province>福建</province>
		<city>莆田</city>
		<areacode>0594</areacode>
		<zip>351100</zip>
		<company>国美极信</company>
		<card/>
	</result>
	<error_code>0</error_code>
</root>
```

### DOM4J-XPATH网络解析

（<a href=#C3>返回</a><a id="G3" href=#>*</a>）

```java
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.Scanner;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-02-28 8:56
 * @Modified_By:
 * @Project： 解析网络文件
 */
public class Demo3 {
    public static void main(String[] args) throws IOException, DocumentException, InterruptedException {
        System.out.println("手机信息查询");
        System.out.print("输查询的手机号码 ： ");
        String phone = new Scanner(System.in).nextLine();
        URL url = new URL("http://apis.juhe.cn/mobile/get? phone="+phone+"&dtype=xml&key=9f3923e8f87f1ea50ed4ec8c39cc9253");
        URLConnection conn = url.openConnection();
        InputStream is = conn.getInputStream();
        SAXReader sr = new SAXReader();
        Document doc = sr.read(is);
        String code = doc.selectSingleNode("//resultcode").getText();
        if ("200".equals(code)){
            String province = doc.selectSingleNode("//province").getText();
            String city = doc.selectSingleNode("//city").getText();
            String postCode = doc.selectSingleNode("//zip").getText();
            String supplier = doc.selectSingleNode("//company").getText();
            Thread.sleep(1000);
            printInfo(province , city , postCode , supplier);
        } else {
            System.out.println("请从新输入号码 ！ ");
        }
        is.close();
    }
    
    public static void printInfo(String province , String city , String postCode , String supplier) {
        System.out.println("==============");
        if (province.equals(city)){
            System.out.println("归属地 ： " + province);
        } else {
            System.out.println("归属地 ： " + province + " " + city);
        }
        System.out.println("邮政编号 ： " + postCode);
        System.out.println("运营商 ： " + supplier);
        System.out.println("==============");
    }
}

/*
手机信息查询
输查询的手机号码 ： 17155943925
==============
归属地 ： 福建 莆田
邮政编号 ： 351100
运营商 ： 国美极信
==============
*/
```
**xml网络文档**

```xml
<root nighteye="disabled">
	<resultcode>200</resultcode>
	<reason>Return Successd!</reason>
	<result>
		<province>福建</province>
		<city>莆田</city>
		<areacode>0594</areacode>
		<zip>351100</zip>
		<company>国美极信</company>
		<card/>
	</result>
	<error_code>0</error_code>
</root>
```

### XML生成

生成于项目根路径

```java
import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.XMLWriter;

import java.io.*;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-02-28 19:38
 * @Modified_By:
 * @Project： XML生成
 */

public class Demo {
    public static void main(String[] args) throws IOException {
        Document doc = DocumentHelper.createDocument();
        Element root = doc.addElement("peoples");
        
        //后宫
        String[] names ={
          "黑猫" , "雪乃" , "黑子" , "柏竹" , "红豆" , "智乃" , "蕾姆" , "纱雾" , "琪露诺" , "麻衣"
        };
        String[] ages = {
                "14" , "18" , "16" , "20" , "12" , "12" , "17" , "14" , "13" , "18"
        };
        
        for (int i = 0 ; i < 10 ; i++) {
            Element people = root.addElement("people");
            people.addAttribute("id",1000+i+"");
            Element name = people.addElement("name");
            Element age = people.addElement("age");
            name.setText(names[i]);
            age.setText(ages[i]);
        }
    
        FileOutputStream fos = new FileOutputStream("Demo.xml");
        XMLWriter xw = new XMLWriter(fos);
        xw.write(doc);
        
        xw.close();
        fos.close();
    }
}

/* 结果：代码格式化后的 xml文件 

<?xml version="1.0" encoding="UTF-8"?>
<peoples>
    <people/>
    <people id="1000">
        <name>黑猫</name>
        <age>14</age>
    </people>
    <people id="1001">
        <name>雪乃</name>
        <age>18</age>
    </people>
    <people id="1002">
        <name>黑子</name>
        <age>16</age>
    </people>
    <people id="1003">
        <name>柏竹</name>
        <age>20</age>
    </people>
    <people id="1004">
        <name>红豆</name>
        <age>12</age>
    </people>
    <people id="1005">
        <name>智乃</name>
        <age>12</age>
    </people>
    <people id="1006">
        <name>蕾姆</name>
        <age>17</age>
    </people>
    <people id="1007">
        <name>纱雾</name>
        <age>14</age>
    </people>
    <people id="1008">
        <name>琪露诺</name>
        <age>13</age>
    </people>
    <people id="1009">
        <name>麻衣</name>
        <age>18</age>
    </people>
</peoples>

*/
```
### XML类对象形式生成

生成于项目根路径

```java
package Demo2;

import com.thoughtworks.xstream.XStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Writer;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-02-28 20:41
 * @Modified_By:
 * @Project： XStream生成XML文件 （对象）
 */
public class Demo2 {
    public static void main(String[] args) throws IOException {
        XStream x = new XStream();
        
        x.alias("people" , People.class);
        
        People p1 = new People("智乃" , "12");
        People p2 = new People("蕾姆" , "17");
        People p3 = new People("黑子" , "16");
        
        //前期学习不太会太多，用了较粗暴的方式生成
        FileOutputStream fos = new FileOutputStream("Demo2.xml");
        Writer w = new PrintWriter(fos);
        w.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        w.write("<peoples>");
        w.write(x.toXML(p1));
        w.write(x.toXML(p2));
        w.write(x.toXML(p3));
        w.write("</peoples>");
    
        w.close();
        fos.close();
    }
}

/*结果：代码格式化后的 xml文件 

<?xml version="1.0" encoding="UTF-8"?>
<peoples>
    <people>
        <name>智乃</name>
        <age>12</age>
    </people>
    <people>
        <name>蕾姆</name>
        <age>17</age>
    </people>
    <people>
        <name>黑子</name>
        <age>16</age>
    </people>
</peoples>

*/
```
文章会持续更新！！！

### Gson序列化与反序列化

（<a href=#C4>返回</a><a id="G4" href=#>*</a>）

```java
package Gson;
import UtilClass.Book;
import UtilClass.People;
import com.google.gson.Gson;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-03-01 10:37
 * @Modified_By:
 * @Project：Gson实现JSON
 */
public class Demo {
    public static void main(String[] args) {
        //序列化
        People people = new People("陈二狗" , "23");
        Gson gson = new Gson();
        String json = gson.toJson(people);
        System.out.println(json);
        //json = {"name":"陈二狗","age":"23"}
        
        //反序列化
        People people2 = gson.fromJson(json , People.class);
        System.out.println(people2.getName());
        System.out.println(people2.getAge());
        
        
        
        System.out.println("================");
        // 难度提升
        //序列化
        //页数 对应 内容
        HashMap<Integer , List<String>> data = new HashMap<>();
        List<String> array = new ArrayList<>();
        array.add("发");
        array.add("法");
        array.add("罚");
        array.add("伐");
        array.add("阀");
        //。。。
        data.put(189 , array);
        
        Book book = new Book("汉语字典","文字API" , data);
        json = gson.toJson(book);
        System.out.println(json);
        /*
        {
            "name":"汉语字典",
            "info":"文字API",
            "data":{
                "189":["发","法","罚","伐","阀"]
            }
        }
        */
        
        //反序列化
        Book book2 = gson.fromJson(json , Book.class);
        System.out.println(book2.getData());
    }
}


/*

{"name":"陈二狗","age":"23"}
陈二狗
23
================
{"name":"汉语字典","info":"文字API","data":{"189":["发","法","罚","伐","阀"]}}
{189=[发, 法, 罚, 伐, 阀]}

*/
```
### FastJson序列化与反序列化

（<a href=#C5>返回</a><a id="G5" href=#>*</a>）

```java
package FastJson;

import UtilClass.Book;
import UtilClass.People;
import com.alibaba.fastjson.JSON;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-03-01 11:13
 * @Modified_By:
 * @Project： FastJson实现JSON
 */
public class Demo {
    public static void main(String[] args) {
        //序列化
        People people = new People("陈二狗" , "23");
        String json = JSON.toJSONString(people);
        System.out.println(people);
        //json = UtilClass.People{name='陈二狗', age='23'}     包.类{类属性}
        
        //反序列化
        People people2 = JSON.parseObject(json , People.class);
        System.out.println(people2.getName());
        System.out.println(people2.getAge());
    
        System.out.println("================");
        // 难度提升
        //序列化
        //页数 对应 内容
        HashMap<Integer , List<String>> data = new HashMap<>();
        List<String> array = new ArrayList<>();
        array.add("发");
        array.add("法");
        array.add("罚");
        array.add("伐");
        array.add("阀");
        //。。。
        data.put(189 , array);
    
        Book book = new Book("汉语字典","文字API" , data);
        json = JSON.toJSONString(book);
        System.out.println(json);
        /*
        {
            "data":{
                189:["发","法","罚","伐","阀"]
            },
            "info":"文字API",
            "name":"汉语字典"
        }
         */
    
        //反序列化
        Book book2 = JSON.parseObject(json , Book.class);
        System.out.println(book2.getData());
    }
}

/*
UtilClass.People{name='陈二狗', age='23'}
陈二狗
23
================
{"data":{189:["发","法","罚","伐","阀"]},"info":"文字API","name":"汉语字典"}
{189=[发, 法, 罚, 伐, 阀]}
 */

```
**People工具类**

```java
package UtilClass;

import java.util.Objects;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-03-01 10:36
 * @Modified_By:
 * @Project：
 */
public class People {
    String name;
    String age;
    
    public People() {
    }
    
    public People(String name , String age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return "UtilClass.People{" +
                "name='" + name + '\'' +
                ", age='" + age + '\'' +
                '}';
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        People people = (People) o;
        return Objects.equals(name , people.name) &&
                Objects.equals(age , people.age);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name , age);
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getAge() {
        return age;
    }
    
    public void setAge(String age) {
        this.age = age;
    }
}
```
**Book工具类**

```java
package UtilClass;


import java.util.HashMap;
import java.util.List;
import java.util.Objects;

/**
 * @Author: 柏竹
 * @Description: 一个简洁主义...
 * @Date_Created_in: 2021-03-01 10:48
 * @Modified_By:
 * @Project：
 */
public class Book {
    String name;
    String info;
    HashMap<Integer , List<String>> data;
    
    public Book() {
    }
    
    public Book(String name , String info , HashMap<Integer, List<String>> data) {
        this.name = name;
        this.info = info;
        this.data = data;
    }
    
    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", info='" + info + '\'' +
                ", data=" + data +
                '}';
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Book book = (Book) o;
        return Objects.equals(name , book.name) &&
                Objects.equals(info , book.info) &&
                Objects.equals(data , book.data);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name , info , data);
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getInfo() {
        return info;
    }
    
    public void setInfo(String info) {
        this.info = info;
    }
    
    public HashMap<Integer, List<String>> getData() {
        return data;
    }
    
    public void setData(HashMap<Integer, List<String>> data) {
        this.data = data;
    }
}
```