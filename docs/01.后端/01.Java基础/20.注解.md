---
title: Java注解
date: 2020-02-18 00:00:00
permalink: /backend/zyaf2n
categories:
  - 后端
  - Java基础
tags:
  - Java
author: 柏竹
---

# Java注解

## 概述

> **Class Annotation**
>
> java.lang.Object
> java.text.Annotation

java提供了Annotation功能，又称为Java标注，
用于对 类、构造方法、成员变量、方法、参数等声明，该功能不会影响程序的运行，会对编译器警告等辅助工具产生影响

- 编译格式检查
- 反射中解析
- 生成帮助文档
- 跟踪代码依赖
- 。。。

## 内置注解

### @Override

**重写** 编译器会验证 `@Override` 下的方法名是否 重写方法，必须的！

### @Deprecated

**废弃** 注解之后，表示此 方法/类 不再建议使用，调用时也会出现删除线，可以用但不建议，因 有更好的 方法/类 ！

### @SafeVarargs

**泛型** 写的 方法/构造方法 认为类型是安全的，那么你也就可以使用@SafeVarargs 来跳过安全警告

**用于：**

- 构造方法的参数个数不确定（数组形式）
  如：public void Test(int... array)
- static声明的 方法
- final声明的 方法

### @FunctionalInterface

**函数接口** 仅仅只包含一个抽象方法的接口

### @Repeatable

**多注解** 可以在同一个声明上使用多次

### @SuppressWarnings

**抑制警告** 取消编译器对代码产生的警告

@SuppressWarnings("unchecked") `[^ 抑制单类型的警告]`
@SuppressWarnings("unchecked","rawtypes") `[^ 抑制多类型的警告]`
@SuppressWarnings("all") `[^ 抑制所有类型的警告]`

**参数说明**

|                        关键值                         |                        作用                        |
| :---------------------------------------------------: | :------------------------------------------------: |
|           <font color = #05ffdc>all</font>            |                    抑制所有警告                    |
|          <font color = #05ffdc>boxing</font>          |            抑制装箱、拆箱操作时候的警告            |
|           <font color = #05ffdc>cast</font>           |                 抑制映射相关的警告                 |
|         <font color = #05ffdc>dep-ann</font>          |                 抑制启用注释的警告                 |
|       <font color = #05ffdc>deprecation</font>        |                  抑制过期方法警告                  |
|       <font color = #05ffdc>fallthrough</font>        |          抑制确在switch中缺失breaks的警告          |
|         <font color = #05ffdc>finally</font>          |           抑制finally模块没有返回的警告            |
|          <font color = #05ffdc>hiding</font>          |         抑制相对于隐藏变量的局部变量的警告         |
|    <font color = #05ffdc>incomplete-switch</font>     |              忽略没有完整的switch语句              |
|           <font color = #05ffdc>nls</font>            |                忽略非nls格式的字符                 |
|           <font color = #05ffdc>null</font>           |                  忽略对null的操作                  |
|         <font color = #05ffdc>ratypes</font>          |        使用generics时忽略没有指定相应的类型        |
|       <font color = #05ffdc>restriction</font>        |          抑制禁止使用劝阻或禁止引用的警告          |
|          <font color = #05ffdc>serial</font>          | 忽略在serializable类中没有声明serialVersionUID变量 |
|      <font color = #05ffdc>static-access</font>       |            抑制不正确的静态访问方式警告            |
|     <font color = #05ffdc>synthetic-access</font>     |       抑制子类没有按最优方法访问内部类的警告       |
|        <font color = #05ffdc>unchecked</font>         |           抑制没有进行类型检查操作的警告           |
| <font color = #05ffdc>unqualified-field-access</font> |             抑制没有权限访问的域的警告             |
|          <font color = #05ffdc>unused</font>          |             抑制没被使用过的代码的警告             |

**实例.1**

```java
public class Demo extends People implements IntfTest{
    
    /**
     *  重写父类
     */
    @Override
    public String getName(){
        return new String("已重写");
    }
    
    public static void main(String[] args) {
        People p = new People();
        p.setName("Test");
    }
    
    @Override
    public void show() {
        System.out.println("测试输出");
    }
}

class People{
    String name;
    
    public People() { }
    
    public String getName() {
        return name;
    }
    
    /** 废弃方法
     * 此方法以废弃 。建议使用 setName2方法
     * @param name 姓名
     */
    @Deprecated
    public void setName(String name) {
        this.name = name;
    }
    public void setName2(String name) {
        if (name == null || name.equals(" ")){
            return;
        }
        this.name = name;
    }
}

@FunctionalInterface
interface IntfTest{
    void show();
}
```

**实例.2**

```java
import java.util.ArrayList;
import java.util.List;

@SuppressWarnings("all")
public class MySuppressWarnings {
    public static void main(String[] args) {
        @SuppressWarnings("unchecked")
        List<Boolean> bool = new ArrayList();
        // bool.add(true);
    }
}

@SuppressWarnings("unchecked")
class Book{}
```

## 元注解

作用在其他注解的注解

### @Retention

**策略属性** 定义注解时，`@Retention`用于指定注解有效范围，默认值 `CLASS`。`@Retention` 的策略设置有 `RetentionPolicy枚举类` 中的常量

| RetentionPolicy枚举常量 | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| SOURCE                  | 编译器处理完就没用了，有效范围最小                           |
| CLASS                   | 注解将会存储于类对应的 `.class文件` 中，运行时不加载Annotation到JVM中 |
| RUNTIME                 | 注解将会存储于类对应的 `.class文件` 中，在运行时加载Annotation到JVM中，范围最大 |

### @Documented

**文档注释** 标记注解是否包含在用户文档中javadoc

### @Target

**设置类型** 设置注解类型，指定使用地方 。若没有 `@Target` ，则任何地方都可用。`@Target`的设置有枚举类ElementType中的常量

| ElementType枚举常量 | 说明                               |
| ------------------- | ---------------------------------- |
| ANNOTATION_TYPE     | 用于Annotation类型                 |
| TYPE                | 用于类、接口、枚举、Annotation类型 |
| CONSTRUCTOR         | 用于构造方法                       |
| FIELD               | 用于成员变量、枚举常量             |
| METHOD              | 用于方法                           |
| PARAMETER           | 用于参数                           |
| LOCAL_VARIABLE      | 用于局部变量                       |
| PACKAGE             | 用于包                             |

### @Inherited

**继承注解** 子类继承 父类使用的注解

## 自定义注解

定义用到 interface关键字 ，前面需加 @ ，定义Annotation类型关键字为： `@interface`

```java
public @interface MyAnnotation{
    String value() default "ABC";
    Class type() default void.class;
}
```

**注意：**

1. 定义的注解，自动继承 `java.lang,annotation.Annotation接口`
2. 注解中的每一个方法，实际是声明的注解配置参数
    - 方法的名称就是 配置参数的名称
    - 方法的返回值类型，就是配置参数的类型。只能是：基本类型/Class/String/enum
3. 关键字 `default` 用于声明参数的默认值
4. 如果只有一个参数成员，一般参数名为value
5. 注解元素必须要有值

**实例.1**

```java
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

public class MyRepeatable {
    
    String info;
    @Repeatable (RepeatableTests.class)
    public @interface RepeatableTest{
        String name();
        String date();
        String change() default "暂无优化";;
    }
    @Retention (RetentionPolicy.RUNTIME)
    public @interface RepeatableTests{
        RepeatableTest[] value();
    }
    
    @RepeatableTest(name="Jon" , date = " 2021-02-03 07:02" , change= "if保险")
    @RepeatableTest(name="K" , date = " 2021-03-13 12:01" , change= "修改变量")
    @RepeatableTest(name="Jccn" , date = " 2021-03-04 12:04" , change= "设置变量")
    @RepeatableTest(name="Cin" , date = " 2021-03-23 11:06")
    public void setInfo(String info) {
        if (info == null || info == " "){
            info = null;
            return;
        }
        this.info = this.info;
    }
    
}
```

**实例.2**

```java
import java.lang.annotation.*;

public class Demo {
    public static void main(String[] args) {
        start();
    }
    
    @MyAnnotation(Modified_By = "老刘" , info = "if判断")
    private static void start() {
        System.out.println("注释");
    }
}

/** 设置用户
 * @author Sans
 */
@Documented
@Inherited
@Retention(RetentionPolicy.CLASS)
@Target({ElementType.CONSTRUCTOR,ElementType.TYPE,ElementType.METHOD})
@interface MyAnnotation{
    String Modified_By() default "root";
    String info() default "null";
}
```
