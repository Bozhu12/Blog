---
title: Java事件
date: 2020-02-18 00:00:00
permalink: /backend/tfnnik
categories: 
  - 后端
  - Java基础
tags: 
  - Java
  - 基础
author: 
  name: 柏竹
  link: https://github.com/Bozhu12
titleTag: 原创
---

# Java事件

## 动作事件

> **Class ActionEvent**
>
> java.lang.Object 
> java.util.EventObject 
> java.awt.AWTEvent 
> java.awt.event.ActionEvent 

ActionEvent类 监听控件动作，ActionListener接口 也可实现处理事件监听

抽象方法

<font color = #05ffdc>actionPerformed(ActionEvent e);</font> 控件回车

## 焦点事件监听器

> **Class FocusEvent**
>
> java.lang.Object 
> java.util.EventObject 
> java.awt.AWTEvent 
> java.awt.event.ComponentEvent 
> java.awt.event.FocusEvent 

FocusEvent类 控件焦点监听，以光标视为焦点，失去或激活都会触发事件，FocusListener接口 也可实现处理事件监听

抽象方法

> <font color = #05ffdc>focusGained(FocusEvent e); </font> 获取焦点
>
> <font color = #05ffdc>focusLost(FocusEvent e); </font> 失去焦点

## 键盘事件

> **Class KeyEvent**
>
> java.lang.Object 
> java.util.EventObject 
> java.awt.AWTEvent 
> java.awt.event.ComponentEvent 
> java.awt.event.InputEvent 
> java.awt.event.KeyEvent 

KeyEvent类 键盘监听，KeyListener接口 也可实现处理事件监听

抽象方法

> <font color = #05ffdc>keyTyped(KeyEvent e); </font> 点击
>
> <font color = #05ffdc>KeyPressed(keyEvent e); </font> 被按下（未松也触发）
>
> <font color = #05ffdc>KeyReleased(keyEvent e); </font> 松开释放

方法自查API

**注意**：KeyEvent类中以“VK_”为前缀的静态常量代表键盘的keyCode（键盘按键 

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;

public class KeyEventTest extends JFrame {

    private JTextField jtf = new JTextField(3);
    private JLabel jl = new JLabel("H");
    private Container container = getContentPane();

    public KeyEventTest(){
        setBounds(400, 300, 90, 80);
        setDefaultCloseOperation(3);
        jtf.setFont(new Font("微软雅黑",Font.PLAIN,16));
        jl.setFont(new Font("微软雅黑",Font.PLAIN,16));
        //窗体流布局
        container.setLayout(new FlowLayout());
        //添加组件
        container.add(jtf);
        container.add(jl);

        jtf.addKeyListener(new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {
                System.out.println("点击了键盘");
            }

            @Override
            public void keyPressed(KeyEvent e) {
                System.out.println(e.getKeyText(e.getKeyCode()));
            }

            @Override
            public void keyReleased(KeyEvent e) {
                jtf.setText("");
                jl.setText(e.getKeyText(e.getKeyCode()));
            }
        });

        setVisible(true);
    }

    public static void main(String[] args) {
        new KeyEventTest();
    }
}
```

<img src="https://image.bozhu12.cc/myblog/Java/Java35.gif"/>

## 鼠标事件

> **Class MouseEvent**
>
> java.lang.Object 
> java.util.EventObject 
> java.awt.AWTEvent 
> java.awt.event.ComponentEvent 
> java.awt.event.InputEvent 
> java.awt.event.MouseEvent 

MouseEvent类 键盘监听类，MouseListener接口也可实现处理事件监听

MouseListener接口有5个抽象方法，分为不同的触发方式

> <font color = #05ffdc>mouseEntered(MouseEvent e); </font> 鼠标移入组件触发\
>
> <font color = #05ffdc>mousePressed(MouseEvent e); </font> 鼠标按下触发
>
> <font color = #05ffdc>mouseReleased(MouseEvent e); </font> 鼠标释放触发
>
> <font color = #05ffdc>mouseClicked(MouseEvent e); </font> 鼠标单击触发
>
> <font color = #05ffdc>mouseExited(MouseEvent e); </font> 鼠标移出组件触发

方法自查API

**MouseEvent类静态常量**

| 静态常量 | 值   | 键       |
| -------- | ---- | -------- |
| BUTTON1  | 1    | 鼠标左键 |
| BUTTON2  | 2    | 鼠标滚轮 |
| BUTTON3  | 3    | 鼠标右键 |

```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

public class MouseEventTest extends JFrame implements MouseListener {

    private Container c = getContentPane();
    private JButton jb = new JButton("清空测试");
    private JLabel jl = new JLabel("H");
    private JTextArea jta = new JTextArea(15,35);
    private JScrollPane jsp = new JScrollPane(jta);
    private String scr = "";
    private static String tap = "(暂无)";

    public MouseEventTest(){
        setLayout(new FlowLayout());
        setDefaultCloseOperation(3);
        setBounds(400, 300, 400, 330);

        //边框颜色
        jsp.setBorder(BorderFactory.createLineBorder(Color.RED));

        c.add(jb);
        c.add(jl);
        c.add(jsp);

        //添加监听器
        jb.addMouseListener(this);
        jta.addMouseListener(this);
        jb.addActionListener(new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent e) {
                jta.setText("");
            }
        });
        setVisible(true);
    }


    //鼠标移入组件
    @Override
    public void mouseEntered(MouseEvent e) {
        if (e.getSource() == jb){
            scr = "按钮：";
        }
        if (e.getSource() == jta){
            scr = "文本框：";
        }
        jl.setText(scr+"移入组件");
    }
    //鼠标移出组件
    @Override
    public void mouseExited(MouseEvent e){
        jl.setText(scr+"移出组件");
    }
    //鼠标释放
    @Override
    public void mouseReleased(MouseEvent e){
        annpanduan(e);
        jl.setText(scr+"松开"+tap);
        jta.append(scr+"松开"+tap+"\n");
    }

    //鼠标按下
    @Override
    public void mousePressed(MouseEvent e){
        annpanduan(e);
        jl.setText(scr+"按下"+tap);
        jta.append(scr+"按下"+tap+"\n");

    }

    //鼠标单击
    @Override
    public void mouseClicked(MouseEvent e){
        annpanduan(e);
        jl.setText(scr+"单击"+tap);
        jta.append(scr+"单击"+tap+"\n");
    }

    public static void annpanduan(MouseEvent e){
        int source = e.getButton();
        switch(source){
            case 1 : tap = "(左键)"; break;
            case 2 : tap = "(中键)"; break;
            case 3 : tap = "(右键)"; break;
        }
    }

    public static void main(String[] args) {
        new MouseEventTest();
    }
    
}
```

<img src="https://image.bozhu12.cc/myblog/Java/Java36.gif" style="zoom:80%;" />

## 窗体事件

### 窗体焦点事件

WindowFocusListener接口，捕获当前窗体焦点变化
抽象方法

> <font color = #05ffdc>windowGainedFocus(WindowEvent e); </font> 获取焦点触发
>
> <font color = #05ffdc>windowLosetFocus(WindowEvent e); </font>  失去焦点触发

```java
import javax.swing.*;
import java.awt.event.WindowEvent;
import java.awt.event.WindowFocusListener;

public class WindowFocusTest extends JFrame implements WindowFocusListener {

    public WindowFocusTest(){
        setBounds(400,300,400,300);
        setDefaultCloseOperation(3);
        //为窗体添加焦点事件
        addWindowFocusListener(this);
        setVisible(true);
    }

    @Override
    public void windowGainedFocus(WindowEvent e){//获取焦点
        System.out.println("获取焦点");
    }
    @Override
    public void windowLostFocus(WindowEvent e){//失去焦点
        System.out.println("失去焦点");
    }

    public static void main(String[] args) {
        new WindowFocusTest();
    }
}
```

### 窗体状态事件

WindowStateListener接口，捕获当前窗体正常、最大、最小化的变化
抽象方法

> <font color = #05ffdc>windowStateChanged(WindowEvent e); </font> 窗体发生变化时触发

窗体状态变化后，获取状态的方法

<font color = #05ffdc>（int）getNewState() </font>  获取窗体 现在 的状态

<font color = #05ffdc>（int）getOldState() </font>  获取窗体 以前 的状态

窗体状态的静态常量

| 静态常量       | 值   | 键     |
| -------------- | ---- | ------ |
| NORMAL         | 0    | 正常化 |
| ICONIFIED      | 1    | 最小化 |
| MAXIMIZED_BOTH | 6    | 最大化 |

```java
import javax.swing.*;
import java.awt.event.WindowEvent;
import java.awt.event.WindowFocusListener;
import java.awt.event.WindowStateListener;

public class WindowBasicTest extends JFrame implements WindowFocusListener, WindowStateListener {

    public WindowBasicTest(){
        setBounds(400,300,400,300);
        setDefaultCloseOperation(3);
        //为窗体添加焦点事件
        addWindowFocusListener(this);
        addWindowStateListener(this);
        setVisible(true);
    }

    @Override
    public void windowGainedFocus(WindowEvent e){//获取焦点
        System.out.println("获取焦点");
    }
    @Override
    public void windowLostFocus(WindowEvent e){//失去焦点
        System.out.println("失去焦点");
    }

    @Override
    public void windowStateChanged(WindowEvent e){//窗体发生变化
        //原旧状态 --> 新状态
        System.out.println(VaryString(e.getOldState())+" --> "+VaryString(e.getNewState()));
    }
    public String VaryString(int e){
        String scr = null;
        switch(e){
            case 0: scr = "正常化";break;
            case 1: scr = "最小化";break;
            case 6: scr = "最大化";break;
            default: scr = "最小化";break;
        }
        return scr;
    }

    public static void main(String[] args) {
        new WindowBasicTest();
    }
}
```



### 其他窗体事件

WindowListener接口，捕获窗体的变化情况
抽象方法

> <font color = #05ffdc>windowActivated(WindowEvent e); </font> 激活触发（类似焦点
>
> <font color = #05ffdc>windowDeactivated(WindowEvent e); </font> 非激活触发
>
> <font color = #05ffdc>windowIconified(WindowEvent e); </font> 最小化触发
>
> <font color = #05ffdc>windowDeiconified(WindowEvent e); </font> 非最小化触发
>
> <font color = #05ffdc>windowOpened(WindowEvent e); </font> 窗口打开触发
>
> <font color = #05ffdc>windowClosing(WindowEvent e); </font> 关闭窗口触发
>
> <font color = #05ffdc>windowClosed(WindowEvent e); </font> 已关闭窗口触发

### 选项事件

> **Class ItemEvent**
>
> java.lang.Object 
> java.util.EventObject 
> java.awt.AWTEvent 
> java.awt.event.ItemEvent 

ItemEvent类 选项监听类，ItemListener接口也可实现处理事件监听
抽象方法

> <font color = #05ffdc>itemStateChanged(ItemEvent e); </font> 选定/取消 时触发

处理选项方法

<font color = #05ffdc>（object）getItem() </font> 获取选中对象
<font color = #05ffdc>（int）getStateChange() </font> 获取选中的状态

getStateChange()方法 返回的静态常量

| 静态常量   | 值   | 键   |
| ---------- | ---- | ---- |
| SELECTED   | 1    | 选中 |
| DESELECTED | 2    | 取消 |

 ```java
import javax.swing.*;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;

public class OptionEventTest extends JFrame implements ItemListener {

    private String[] listdata = {"全部", "复选框", "单选按钮"};
    private JComboBox jcblist = new JComboBox(listdata);
    //选中内容
    private JPanel jpl = new JPanel();
    private JRadioButton jrb = new JRadioButton("单选按钮");
    private JCheckBox jcb = new JCheckBox("复选框");
    private Container c = getContentPane();

    public OptionEventTest() {
        setBounds(400, 300, 200, 140);
        setDefaultCloseOperation(3);

        jpl.add(jrb);
        jpl.add(jcb);
        jpl.setSize(200, 280);
        jpl.setBorder(BorderFactory.createTitledBorder("显示区"));

        c.add(jcblist, BorderLayout.NORTH);
        c.add(jpl, BorderLayout.CENTER);

        //监听
        jrb.addItemListener(this);
        jcb.addItemListener(this);
        jcblist.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                switch ((String) e.getItem()) {
                    case "单选按钮":
                        jrb.setVisible(true);
                        jcb.setVisible(false);
                        break;
                    case "复选框":
                        jrb.setVisible(false);
                        jcb.setVisible(true);
                        break;
                    default:
                        jrb.setVisible(true);
                        jcb.setVisible(true);
                        break;
                }
            }
        });

        setVisible(true);
    }

    @Override
    public void itemStateChanged(ItemEvent e) {// 选中 ro 取消
        //单选按钮和复选框的父类
        JToggleButton tmp = (JToggleButton) e.getSource();
        String type = tmp.getText();
        switch (e.getStateChange()) {
            case 1:
                System.out.println("选中" + type);
                break;
            case 2:
                System.out.println("取消" + type);
                break;
            default:
                System.out.println("错误");
                break;
        }
    }

    public static void main(String[] args) {
        new OptionEventTest();
    }
}
 ```

<img src="https://image.bozhu12.cc/myblog/Java/Java37.gif"/>



