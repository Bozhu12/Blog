---
title: ruoyi-vue-plus-国际化
date: 2024-02-06 00:00:00
author: 柏竹
permalink: /ruoyi-vue-plus/12
categories: 
  - 框架
tags: 
  - ruoyi-vue-plus
  - 国际化
---

## 国际化

根据用户选择自己国家的语言 , 从而提高系统的使用体验

**参考文档**

- **命名文件规范 :** [https://zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/50620931?utm_id=0) 
- **SpringBoot官方文档 :** [https://docs.spring.io](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.internationalization) 
- **ruoyi-vue-plus应用文档 :** [https://plus-doc.dromara.org](https://plus-doc.dromara.org/#/ruoyi-vue-plus/framework/association/i18n) 
- **ruoyi前端应用文档 :** [https://doc.ruoyi.vip](https://doc.ruoyi.vip/ruoyi-vue/document/htsc.html#%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%B5%81%E7%A8%8B) 
- **ruoyi后端应用文档 :** [https://doc.ruoyi.vip](https://doc.ruoyi.vip/ruoyi/document/htsc.html#%E5%90%8E%E5%8F%B0%E5%9B%BD%E9%99%85%E5%8C%96%E6%B5%81%E7%A8%8B) 

## 后端

后端采用SpringBoot自带的国际化消息响应 , 响应分为多种

**实现大致流程**

1. 配置 `i18n资源` 路径 , 以及前缀文件名称 , 并添加国际化文件
2. 添加 国际化文件 , 文件名必须遵守命名规范
3. 配置类 请求拦截解析 , 根据请求头判断语言
4. 新建类 国际化工具类 , 用于获取国际化的翻译值
5. 测试应用

### 1. 配置

**`application.yml`配置文件**

```yml
# Spring配置
spring:
  # 资源信息
  messages:
    # 国际化资源文件路径
    basename: i18n/messages
```

以上配置会对应读取为 : `classpath:/i18n/`目录

在资源路径中 , 配置国际化文件 `resources/i18n/messages_**_**.properties` 作为相对路径读取的国际化文件 

::: tip

`**_**`作为指定 哪个国家使用哪门语言 , 例如中国 : `messages_zh_CN.properties` 

**国际化命名文件规范 :** [https://zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/50620931?utm_id=0) 

:::

**国际化文件 *resources/i18n/messages_zh_CN.properties*** (中国简体)

```properties
# 这里填写中文翻译
user.username=登陆用户
user.password=登陆密码
# 携带参数
user.welcome=欢迎{1}
user.login=登陆
```

### 3. 配置类配置

通过 `LocaleResolver`解析器 实现 , 请求访问时 , 根据请求头进行识别国际化的语言

**`I18nConfig`配置类**

```java
@Configuration
public class I18nConfig {

    @Bean
    public LocaleResolver localeResolver() {
        return new I18nLocaleResolver();
    }
    
    static class I18nLocaleResolver implements LocaleResolver {

        /**
         * 本地解析 , 根据经请求头进行判断国家和语言控制
         */
        @Override
        public Locale resolveLocale(HttpServletRequest httpServletRequest) {
            String language = httpServletRequest.getHeader("content-language");
            Locale locale = Locale.getDefault();
            if (StrUtil.isNotBlank(language)) {
                String[] split = language.split("_");
                locale = new Locale(split[0], split[1]);
            }
            return locale;
        }

        @Override
        public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) {

        }
    }
}
```

**`ValidatorConfig`配置类** 

Validator校验可以识别i18n关键code信息

```java
@Configuration
public class ValidatorConfig {

    @Autowired
    private MessageSource messageSource;

    /**
     * 配置校验框架 快速返回模式
     */
    @Bean
    public Validator validator() {
        LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
        // 国际化
        factoryBean.setValidationMessageSource(messageSource);
        // 设置使用 HibernateValidator 校验器
        factoryBean.setProviderClass(HibernateValidator.class);
        Properties properties = new Properties();
        // 设置 快速异常返回
        properties.setProperty("hibernate.validator.fail_fast", "true");
        factoryBean.setValidationProperties(properties);
        // 加载配置
        factoryBean.afterPropertiesSet();
        return factoryBean.getValidator();
    }

}
```

### 4. 国际化工具类

以工具类形式进行获取对应国际化语言的翻译值

**`MessageUtils`工具类**

```java
@NoArgsConstructor(access = AccessLevel.PRIVATE)
public class MessageUtils {
	
    private static final MessageSource MESSAGE_SOURCE = SpringUtils.getBean(MessageSource.class);

    /**
     * 根据消息键和参数 获取消息 委托给spring messageSource
     *
     * @param code 消息键
     * @param args 参数
     * @return 获取国际化翻译值
     */
    public static String message(String code, Object... args) {
        // LocaleContextHolder.getLocale() 获取当前国际化的语言的标识 , 如 zh_CN
        return MESSAGE_SOURCE.getMessage(code, args, LocaleContextHolder.getLocale());
    }
    
    /**
     * @param code 消息键
     * @param language 语言
     * @param country 国家
     * @param args 参数
     * @return 获取国际化翻译值
     */
    public static String message(String code, String language, String country,Object... args) {
        return MESSAGE_SOURCE.getMessage(code, args, new Locale(language, country));
    }
}
```

### 5. Demo应用

**简单实例**

PS : 请求头携带 ==content-language: zh_CN== 

```java
@RestController
@Slf4j
@SaIgnore
@RequestMapping("i18")
public class MessageController {

    // 用例测试
    @GetMapping("/msg1")
    public String msg1() {
        return MessageUtils.message("user.username");
    }
    
    // 有参测试
    @GetMapping("/msg2")
    public String msg2(String name) {
        return MessageUtils.message("user.not.exists", name);
    }

    // Validator 校验
    @GetMapping("/msg3")
    public void msg3(@NotBlank(message = "{user.jcaptcha.error}") String name) {
        System.out.println("name = " + name);
    }


}
```

::: tip

Validator 校验不能携带参数 , 携带参数方式可自行实现 , 实现方式 (思路 , 不做演示)

- 在msg中传递参数 , 并且在 Validator异常处理器中进行SPel解析实现
- 自定义注解实现Validator , 调用工具实现

:::

::: warning

以上工具类是通过请求的上下文进行获取国际化语言 , 一旦采用异步 , 那么就无法进行通过请求上下文进行获取请求头 . 

异步建议自行传递标识语言的

:::

## 前端

前端的国际化涉及到的部分

- 请求响应接口语言控制
- 页面语言控制

### 接口控制

接口可以通过配置通用的请求访问的 js文件 进行配置初始化值 , 或者采用状态管理组合请求拦截器形式进行控制

**`utils/request.js`请求配置**

::: details 点击展开代码

```js {16}
import axios from 'axios'
import { Notification, MessageBox, Message, Loading } from 'element-ui'
import store from '@/store'
import { getToken } from '@/utils/auth'
import errorCode from '@/utils/errorCode'
import { tansParams, blobValidate } from "@/utils/ruoyi";
import cache from '@/plugins/cache'
import { saveAs } from 'file-saver'

let downloadLoadingInstance;
// 是否显示重新登录
export let isRelogin = { show: false };

axios.defaults.headers['Content-Type'] = 'application/json;charset=utf-8'
// 对应国际化资源文件后缀
axios.defaults.headers['Content-Language'] = 'zh_CN'
// 创建axios实例
const service = axios.create({
  // axios中请求配置有baseURL选项，表示请求URL公共部分
  baseURL: process.env.VUE_APP_BASE_API,
  // 超时
  timeout: 10000
})

// request拦截器
service.interceptors.request.use(config => {
  // 是否需要设置 token
  const isToken = (config.headers || {}).isToken === false
  // 是否需要防止数据重复提交
  const isRepeatSubmit = (config.headers || {}).repeatSubmit === false
  if (getToken() && !isToken) {
    config.headers['Authorization'] = 'Bearer ' + getToken() // 让每个请求携带自定义token 请根据实际情况自行修改
  }
  // get请求映射params参数
  if (config.method === 'get' && config.params) {
    let url = config.url + '?' + tansParams(config.params);
    url = url.slice(0, -1);
    config.params = {};
    config.url = url;
  }
  if (!isRepeatSubmit && (config.method === 'post' || config.method === 'put')) {
    const requestObj = {
      url: config.url,
      data: typeof config.data === 'object' ? JSON.stringify(config.data) : config.data,
      time: new Date().getTime()
    }
    // 控制提交频率
    const sessionObj = cache.session.getJSON('sessionObj')
    if (sessionObj === undefined || sessionObj === null || sessionObj === '') {
      cache.session.setJSON('sessionObj', requestObj)
    } else {
      const s_url = sessionObj.url;                  // 请求地址
      const s_data = sessionObj.data;                // 请求数据
      const s_time = sessionObj.time;                // 请求时间
      const interval = 1000;                         // 间隔时间(ms)，小于此时间视为重复提交
      if (s_data === requestObj.data && requestObj.time - s_time < interval && s_url === requestObj.url) {
        const message = '数据正在处理，请勿重复提交';
        console.warn(`[${s_url}]: ` + message)
        return Promise.reject(new Error(message))
      } else {
        cache.session.setJSON('sessionObj', requestObj)
      }
    }
  }
  return config
}, error => {
    console.log(error)
    Promise.reject(error)
})

// response响应拦截器
service.interceptors.response.use(res => {
    // 未设置状态码则默认成功状态
    const code = res.data.code || 200;
    // 获取错误信息
    const msg = errorCode[code] || res.data.msg || errorCode['default']
    // 二进制数据则直接返回
    if (res.request.responseType ===  'blob' || res.request.responseType ===  'arraybuffer') {
      return res.data
    }
    if (code === 401) {
      if (!isRelogin.show) {
        isRelogin.show = true;
        MessageBox.confirm('登录状态已过期，您可以继续留在该页面，或者重新登录', '系统提示', { confirmButtonText: '重新登录', cancelButtonText: '取消', type: 'warning' }).then(() => {
          isRelogin.show = false;
          store.dispatch('LogOut').then(() => {
            location.href = process.env.VUE_APP_CONTEXT_PATH + "index";
          })
      }).catch(() => {
        isRelogin.show = false;
      });
    }
      return Promise.reject('无效的会话，或者会话已过期，请重新登录。')
    } else if (code === 500) {
      Message({ message: msg, type: 'error' })
      return Promise.reject(new Error(msg))
    } else if (code === 601) {
      Message({ message: msg, type: 'warning' })
      return Promise.reject('error')
    } else if (code !== 200) {
      Notification.error({ title: msg })
      return Promise.reject('error')
    } else {
      return res.data
    }
  },
  error => {
    console.log('err' + error)
    let { message } = error;
    if (message == "Network Error") {
      message = "后端接口连接异常";
    } else if (message.includes("timeout")) {
      message = "系统接口请求超时";
    } else if (message.includes("Request failed with status code")) {
      message = "系统接口" + message.substr(message.length - 3) + "异常";
    }
    Message({ message: message, type: 'error', duration: 5 * 1000 })
    return Promise.reject(error)
  }
)

// 通用下载方法
export function download(url, params, filename, config) {
  downloadLoadingInstance = Loading.service({ text: "正在下载数据，请稍候", spinner: "el-icon-loading", background: "rgba(0, 0, 0, 0.7)", })
  return service.post(url, params, {
    transformRequest: [(params) => { return tansParams(params) }],
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    responseType: 'blob',
    ...config
  }).then(async (data) => {
    const isBlob = blobValidate(data);
    if (isBlob) {
      const blob = new Blob([data])
      saveAs(blob, filename)
    } else {
      const resText = await data.text();
      const rspObj = JSON.parse(resText);
      const errMsg = errorCode[rspObj.code] || rspObj.msg || errorCode['default']
      Message.error(errMsg);
    }
    downloadLoadingInstance.close();
  }).catch((r) => {
    console.error(r)
    Message.error('下载文件出现错误，请联系管理员！')
    downloadLoadingInstance.close();
  })
}

export default service
```

:::

通过以上代码不难看出 , axios是写死的请求头 , 但我们可以在请求拦截器中通过vuex进行控制国际语言

**代码省略...** 

### 页面控制

页面内容国际化控制 

**大致流程**

1. 引入依赖
2. 新建文件 , `src`目录 新建lang目录 , 存放国际化文件 `index.js`、`zh.js`、`en.js` (分别创建三个)
3. 引入i18n , 在 `main.js` 引入i18n
4. 设置变量 , 以 全局变量形式 控制 语言切换 和 默认语言 (能存东西的地方就行)
5. 应用测试

流程就不做演示了 , 个人感觉若依框架中的文档也不错

**若依框架应用 :** [https://doc.ruoyi.vip/ruoyi-vue/document/htsc.html](https://doc.ruoyi.vip/ruoyi-vue/document/htsc.html#%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%B5%81%E7%A8%8B) 









