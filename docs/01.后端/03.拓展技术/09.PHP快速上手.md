---
title: PHP快速上手
date: 2022-08-18 00:00:00
permalink: /other/php223
categories:
  - PHP
tags:
author: 柏竹
---

## 前言

以下笔记是对Java有一定基础进行查阅 , 快速入门PHP , 在博客上折腾上了PHP , 苦恼看不懂语法 , 以下代码差不多是博客上选取的内容 ! 

---

**学习来源 :** [http://www.ouyangke.com/back/php/1%E8%AE%A4%E8%AF%86php.html](http://www.ouyangke.com/back/php/1%E8%AE%A4%E8%AF%86php.html)

## 初步语法

PHP是一种运行在服务器端的脚本语言 , 可以嵌入到HTML中 

### 标记

可通过多种标记来区分PHP脚本

- **ASP标记** : `<%php 代码 %>`
- **PHP标记** : `<?php 代码 ?>` 
- **脚本标记 :** `<script language="php">php代码</script>`

> 以上的除了 PHP标记 , 其他都不常用

### 注释

- **行注释 :** `//` & `#`
- **块注释 :** `/* */`

## 变量

php定义变量不需要关键值 , 但必须使用$符号

**应用方式 :** 

```php
// 定义var1变量 & 定义var2变量并赋值
$var1;
$var2 = 1;
// 打印变量var2
echo $var2;
// 重新赋值
$var2 = 2;
// 嵌套html 并且打印var2
echo '<hr/>',$var2;
// 删除变量 (内存剔除)
unset($var2);
// (报错) 因找不到变量
echo $var2;
```

### 变量命名规则

- 变量名必须以"$"开头
- 变量名可由 数字&字母&下划线 组成 , 但必须以 字母&下划线 开头 (数值会报红)
- 允许中文变量

### 预定义变量

提前定义的变量 , 由系统定义的变量 , 存储许多要用到的数据（预定义变量都是数组）

> 和 Java 静态变量 类似 , 一般为 `$_GET` & `$_POST` 等等.. (也是已全大写命名)

### 可变变量

如果 一个变量定义的值 等于 另一个变量的名 , 则可以通过 双$直接进行 宏变量访问 . 示例 : 

```php
// 定义a变量 赋值'b'
$a = 'b';
// 定义b变量 赋值'b'
$b = 'bb';
// 打印变量 $$a 
// 翻译: $a=>b 那么 $b=>bb
echo $$a;
```

### 变量赋值

变量赋值形式有两种 : 

- **值传递 :** 将值拷贝一份进行保存
- **引用传递 :** 将内存地址拷贝进行应用 (与赋值变量共同引用同一地址)

**值传递**

```php
// 栈区开辟存储$a,保存内存值1
$a = 1;   
// 栈区开辟存储$b;发现是赋值运算,故会取出$a的值
$b = $a;
$b = 2;
echo $a,$b; // 1,2
```

**引用传递**

```php
// 栈区开辟存储$a,保存内存值1
$a = 1;   
// 栈区开辟存储$b;发现是引用运算,故会取出$a的地址
$b = &$a;
$b = 2;
echo $a,$b; // 2,2
```

## 常量

常量与变量一样 , 均是用来保存数据的 , 但 常量一旦定义 , 通常不可更改

关键字 : `const`&`constant` : 是在程序运行中，不可改变的量

**定义方式** 

1. 常量函数 : ==define('名',值)== 
2. 关键字 : ==const 名 = 值;== 

```php
// 使用函数定义常量
define('PI',3.1415);   // 注意此处与c++不同，#define 为预处理命令，宏定义，无需加；。。
// 使用const关键字定义
const PI1 = 3;

// 定义特殊常量
define('^-^','smile');
// const ^-^   // 报错

// 访问常量
echo PI1;
// echo ^-^   // 报错
constant('^-^');  // 特殊常量的访问

// 系统常量
echo '<hr/>',PHP_VERSION,'<br/>',PHP_INI_SIZE,'<br/>',PHP_INI_MAX;   // 有符号整形

// 魔术常量
echo '<hr/>',__DIR__,'<br/>',__FILE__,'<br/>',__LINE__; 
echo __LINE__;  // 输出的行数会变
```

**常量命名规则**

1. 前缀不需要 `$`字符
2. 变量名可由 数字&字母&下划线 组成 , 但开头为 字母&下划线 (const定义)
3. 字母全为大写
4. 命名可以使用特殊符号 (define函数)

**系统常量**

系统默认定义好的数据 , 开发者可直接访问 , 常量一般有 : 

- PHP_VERSION : php版本
- PHP_INT_SIZE : 整型int占用字节数
- PHP_INT_MAX : 整型int最大值
- ...

## 数据类型

PHP是种弱类型语言 , 变量本身没有数据类型

### 分类

- **简单数据类型 :** int(4)/float(4)/double(8)/String/boolean
- **符合数据类型 :** Object/Array
- **特殊数据类型 :** NULL/resource(外部数据)

### 类型转换

**两种转化方式 : **

- **自动转化 :** 系统根据自己的需求判断 , 并自行转化
- **手动强制 :** 转化方式和Java一样 ==(类型) 变量名== 

### 类型操作

判断类型 : ==var_dump(变量1, 变量2, ...)== 

获取类型 : ==Gettype(变量)== 

设置类型 : ==Settype(变量名 , 类型)== 

### 字符串特殊性

双引号 可解析变量

单引号 单纯解析文本

```php
$str = "张三";
$res1 = "我是 $str";
$res2 = '我是 $str';
print($res1);
echo '<br>';
print($res2);
/*
我是 张三
我是 $str
*/
```

**拼接** 

可以通过 `.` 进行和字符串进行拼接

```php
<?php
$str = "张三";
echo '名字:' .$str.'(法外狂徒)<br>';
$name = '李';
$name .= '四';
echo $name
?>
/*
名字:张三(法外狂徒)
李四
*/
```

### 数组

应用方式有点区别因此做区分

#### 创建

```php
$arr1 = array();
$arr2 = [];
```

#### 添加

```php
$arr1 = array('1','2','3');
$arr2 = ['a','b','c'];
```

#### 访问

默认情况 会携带有从 0 开始的key (下标索引)

**自定义key也可行!!!** 

```php
$arr1 = array('No.1'=>'1','2','3');
print($arr1['No.1']); //访问自带key
echo '<br>';
var_dump($arr1);
/*
1
array(3) { ["No.1"]=> string(1) "1" [0]=> string(1) "2" [1]=> string(1) "3" }
*/
```

#### 遍历

**打印遍历**

==print_r()==函数 , 遍历 数据+数据key

==var_dump()==函数 , 遍历 数据+数据key+类型

```php
$arr = ['a','b','c'];
print_r($arr);
echo '<br>';
var_dump($arr);
```

**循环遍历**

==foreach(数组 as 遍历变量)==函数 , 数组循环遍历

```php
$arr = ['a','b','c'];
foreach($arr as $v){
    echo $v . '<br>';
}
// 携带key
$arr = ['a','b','c'];
foreach($arr as $k=>$v){
    echo $k .'=>'. $v . '<br>';
}
```

## 运算符

```php
<?php
// 运算符：是一种将数据进行运算的特殊符号，在PHP中一共有十多种运算符。

// 算术运算符   +-*/%
// 比较运算符   > >= < <= ==(数据大小相同即可，无需考虑数据数据类型) != ===(全等于，大小及数据类型均等) !==
$a = '123';  // 字符串
$b = 123;  // 整型
var_dump($a == $b);   // 结果： bool(true)

var_dump($a === $b);   // 结果： bool(false)   不全等于
    
// 逻辑运算符 &&(左边条件与右边条件同时成立) ||(有一个满足即可) !(取反)
$c = 'weekend';
$d = 'goods';

var_dump($c == 'weekend' && $d == 'good');   // bool(false)
var_dump($c == 'weekend' && $d == 'good');   // bool(true)
var_dump(!($c == good));   // bool(true)
         
// 连接运算符  .(将字符串连接一起)   .=(将左边内容与右边内容连接起来并重新赋值)
$e = 'hello';
$f = 123;
echo $e . $f;   // hello 123（注意，此处有强制类型转换）

$e .= $e;      
echo $e;       // hello 123
     
// 错误抑制符：@(可能出错的表达式)，在PHP中有一些错误可以提前预知，但又不想报错，这就需要错误抑制符。
$g = 0;
echo $f % $g;    // 此时会报错
echo @($f % $g); // 不会报错

// 三目运算符(问号表达式) 表达式1 ？ 表达式2：表达式3
echo $g ==0?1:2;
   
// 自操作运算符 ++ --(前置或后置如果只有自操作，则效果一致)
$i = $g++;    // $g = 1;  $i = 0
$i = ++$g;    // $g = 2;  $i = 2;

// 位运算符
/* 
	计算机码：计算机在实际存储数据时，采用的编码规则(二进制规则)
	计算机码：原码、反码和补码。数值本身最左边一位用来充当符号位：正数为0，负数为1；
	原码:数据本身从十进制转换成二进制得到的结果
	     正数，左符号位为0         负数：右符号位为1
	反码：针对负数，符号位不变，其他位取反。
	补码：针对负数，反码+1.（系统中存的为补码）
	以0为例，若是原码，则+0 = 00000000  -0 = 10000000；二者不一样
	         -0 反码 11111111   -0 补码 00000000   与+0一样（正数原码、补码、反码为其本身）。
*/
$j = 5;      // 原码：00000101
$k = -5;     // 原码：10000101  反码：11111010  补码：11111011

// 位运算：取出计算机中最小的单位（bit）进行运算  & | ~(按位取反) ^(按位异或) >>(右移) <<(左移)
// 注：1、系统进行位运算时，均是利用补码进行运算的     2、运算结束之后，必须转换为原码进行显示

// 按位取与         
var_dump($j & $k);    // int(1)
/*    5  00000101
     -5  11111011
      &  00000001  判断：符号位为0，正数，所存即为原码，无需操作
*/

// 按位取反
var_dump(~ $k);       // int(4)
/*
     -5  11111011
      ~  00000100  正数即为原码，
*/
         
// 按位左移
var_dump($k >> 1)   // int(-3)
var_dump($k >> 2)   // int(-2)
/*
     -5  11111011
    >>2  11111110(右移补符号位)
   反码  11111101(补码-1)
   原码  10000010(除符号位均取反)
*/
```

## 流程控制

控制代码走向 , 和Java几乎一样

### 流程控制语法

> PHP本身是嵌入到HTML中的 , 意味着可以在HTML中写 判断&循环 结构

**99乘法表 示例 :** 

```php
<table border=1>
	<?php for($1 = 1 ; $i < 10 ; $i++){ ?>
    <tr>
    	<?php  for($j = 1 ; $j <= $i ; $j++) { ?>
        <td>
        <?php echo $i . ' * ' . $j . ' = ' . $i * $j; ?>
        </td>
        <?php } ?>
    </tr>
    <?php }?>
</table>
```

## 系统函数

| **函数集合名** | **描述**                                                     |
| -------------- | ------------------------------------------------------------ |
| `String`       | 字符串处理函数                                               |
| `Array`        | 数组函数允许您访问和操作数组                                 |
| `MySQLi`       | 允许您访问 MySQL 数据库服务器                                |
| `Date`         | 服务器上获取日期和时间                                       |
| `Filesystem`   | 允许您访问和操作文件系统                                     |
| `Mail`         | 数学函数能处理 integer 和 float 范围内的值                   |
| `HTTP`         | 允许您在其他输出被发送之前，对由 Web 服务器发送到浏览器的信息进行操作 |
| `Calendar`     | 日历扩展包含了简化不同日历格式间转换的函数                   |
| `Directory`    | 允许您获得关于目录及其内容的信息                             |
| `Error`        | 允许您对错误进行处理和记录                                   |
| `Filter`       | 进行验证和过滤                                               |
| `FTP`          | 通过文件传输协议 (FTP) 提供对文件服务器的客户端访问          |
| `MySQL`        | 允许您访问 MySQL 数据库服务器                                |
| `SimpleXML`    | 允许您把 XML 转换为对象                                      |
| `XML`          | 允许我们解析 XML 文档，但无法对其进行验证                    |
| `Zip`          | 压缩文件函数允许我们读取压缩文件                             |

数组官网手册 : https://www.php.net/manual/zh/book.array.php

## 数据库

库操作在php中会涉及到 PDO对象 的应用 , PDO 统一了 PHP 访问各种类型数据库的访问方式

**数据库连接** 

```php
// 提供参数 (数据源&账号&密码)
// 连接源连接Mysql URL : 'mysql:host=localhost;dbname-boke'
$pdo = new PDO($dsn, $username, $password);
// 例如:
$pdo = new PDO('mysql:host=localhost;dbname=boke','root','root');
```

**数据操作**

```php
// 连接
$pdo = new PDO('mysql:host=localhost;dbname=test','root','root');
// 预执行SQL语句
$stmt = $pdo->prepare('SELECT * FROM job;');
// 执行SQL语句
$stmt->execute();
// 取出 结果值(array)
$arr = $stmt->fetchAll();
// 遍历数组
print_r($arr);
```

**编码问题**

```php
// 编码解决方案
// 方案1
header('content-type:text/html;charset=utf-8');
// 方案2
$pdo = new PDO('mysql:host=localhost;dbname=boke','root','root',array(PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES 'utf8';"));
// 方案3
$pdo -> query('SET NAMES utf-8');
```

## 请求&响应

了解前提 需要认识下一下的 . 在一个脚本的全部作用域中都可用

| **变量**    | **描述**                                 |
| ----------- | ---------------------------------------- |
| `$_GET`     | 收集URL请求的传值                        |
| `$_POST`    | 收集表单中的值                           |
| `$_REQUEST` | 包含 `$_POST`&`$_GET`&`$_COOKIE`         |
| `$GLOBALS`  | 全部变量的全局组合数组                   |
| `$_COOKIE`  | 常用于识别用户                           |
| `$_SESSION` | 存储关于用户会话的信息                   |
| `$_FILES`   | 用来获取通过 POST 方法上传文件的相关信息 |
| `$_SERVER`  | 服务器和执行环境信息                     |
| `$_ENV`     | 环境变量                                 |

**表单请求**

```php
<?php
	if(!empty($_GET)){
		print_r($_GET);
	}
?>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Demo</title>
  </head>
  <body>
    <form action="" method="get">
      讲师: <input type="text" name="name" /> <br/>
	  学校:<input type="text" name="school" /> <br/>
      <input type="submit" value="提交" />
    </form>
  </body>
</html>
```

## 类

和Java差不多 , 但每个类都有自己的默认方法如下 : (可以重写这些方法)

| 方法名         | 说明                                          |
| -------------- | --------------------------------------------- |
| `__call`       | 在对象中调用一个不可访问方法时调用            |
| `__callStatic` | 用静态方式中调用一个不可访问方法时调用        |
| `__construct`  | 构造方法                                      |
| `__get`        | 获得一个类的成员变量时调用                    |
| `__set`        | 设置一个类的成员变量时调用                    |
| `__isset`      | 当对不可访问属性调用 isset()或 empty()时调用  |
| `__unset`      | 当对不可访问属性调用 unset()时被调用          |
| `__sleep`      | 执行 serialize()时，先会调用这个函数          |
| `__wakeup`     | 执行 unserialize()时，先会调用这个函数        |
| `__toString`   | 类被当成字符串时的回应方法                    |
| `__invoke`     | 调用函数的方式调用一个对象时的回应方法        |
| `__set_state`  | 调用 var_export()导出类时，此静态方法会被调用 |
| `__clone`      | 当对象复制完成时调用                          |
| `__autoload`   | 尝试加载未定义的类                            |
| `__debugInfo`  | 打印所需调试信息                              |

**大概整体**

```php
// 类
class Student{
	// 成员变量 
	public $name;
	public $age;
	
	// 构造方法
	public function __construct($name,$age){
		$this->name = $name;
		$this->age = $age;
	}
	
	// 普通方法
	public function toString(){
		return 'name: '.$this->name.'<br/>age: '.$this->age;
	}
}
# 实例化 
# $zs = new Student(); (不能无参)
$zs = new Student('zs',22);
// 访问变量
echo $zs->name.'<br/>';
// 访问方法
print($zs->toString());
```

### 继承

可以让某个类型的对象获得另一个类型的对象的属性和方法

关键词继承父类 `extends` (用法跟Java一致)

### 封装

指将客观事物抽象成类，每个类对自身的数据和方法实行保护 

| 权限修饰    | 内类 | 子类 | 外类 |
| ----------- | ---- | ---- | ---- |
| `public`    | Y    | Y    | Y    |
| `protected` | Y    | Y    | N    |
| `private`   | Y    | N    | N    |

### 多态

指同一个实体同时具有多种形式 , 它主要体现在类的继承体系中 

继承对象后 , 可直接重写覆盖父类的方法进行应用 (和Java一致)

### 静态

关键字 `static` 静态修饰 , 可以修饰 成员变量&方法

**访问方式 :** 

```php
# Student类 name&age属性
# 直接类名进行访问
print(Student::$name);
print(Student::toString());
```

### 抽象&接口

`abstract` 关键词定义抽象方法/抽象类

`implements` 关键词使用接口

> 用法几乎和Java一致 略过...

#### 接口常量

常量声明在接口实现还是需要初始化的数据

```php
interface StudentInfo{
    // 默认班级
    const classNum = '000';
    public function toString();
}
class Student{
    private $classNum = StudentInfo::classNum;
    
    private $name;
    private $age;
    public function toString(){
        return 'name:'.$this->name.'&age:'.$this->age.'&classNum:'.$this->classNum;
    }
}
```

### 总结

| **关键词**   | **类外声明** | **声明类** | **声明属性** | **声明方法** | **解释**                       |
| ------------ | :----------: | :--------: | :----------: | :----------: | ------------------------------ |
| `const`      |      √       |            |      √       |              | 定义类常量                     |
| `extends`    |              |     √      |              |              | 扩展类，用一个类去扩展它的父类 |
| `public`     |              |            |      √       |      √       | 公用属性或方法                 |
| `protected`  |              |            |      √       |      √       | 私有属性或方法                 |
| `private`    |              |            |      √       |      √       | 受保护的属性或方法             |
| `static`     |              |     √      |      √       |      √       | 静态成员                       |
| `abstract`   |              |     √      |      √       |              | 抽象类或方法                   |
| `interface`  |              |     √      |              |              | 创建接口                       |
| `implements` |              |     √      |              |              | 实现接口                       |
| `final`      |              |     √      |              |      √       | 类不能被继承                   |
| `parent::`   |              |            |              |              | 访问父类 (继承前提)            |
| `$this->`    |              |            |              |              | 访问本类 (类内前提)            |
| `self::`     |              |            |              |              | 访问本类静态                   |
| `namespace`  |      √       |            |              |              | 创建命名空间                   |

## 命名空间

解决全局成员的命名冲突问题 , 借鉴了文件目录的思想 (解决成员名称冲突的问题

**创建命名空间**

关键字 `namespace` 创建命名空间

```php
// 同时创建两个相同名称的函数
// 写法1
namespace one{
    function php(){}
    const $name;
}
// 写法2
namespace two;
function php(){}
class Student{}
```

### 子命名空间&访问

子命名空间 可以像路径引用的斜杠 `\` 替代 , 代表子集空间

引用时 , 套娃太多的话 , 可通过关键字 ==use 路径 as 别名== 进行别名化引用 

```php
namespace one;
const NAME = 'one';

// 子命名空间
namespace one\two;
const NAME = 'two';

namespace one\two\three;
const NAME = 'three';

// 访问
echo \one\NAME.'<br/>';
echo \one\two\NAME.'<br/>';
echo \one\two\three\NAME.'<hr/>';
// use 路径 as 别名引用
use \one\two as two;
use \one\two\three as three;
echo two\NAME.'<br/>';
echo three\NAME.'<br/>';
```

**引入外部命名空间**

如果外部引入的 子命名空间(最后一位)名称相同 , 会报错 , 需要采用别名化区分 , 例如 : 

```php
// 读取以下文件 
require 'home\one.php'; // 命名空间结构 one\one
require 'home\two.php'; // 命名空间结构 two\one
// 可以发现以上的子命名空间名称相同 , 此时需要别名化
use one\one as o;
use two\one as t;
// 引用ing...
```

## 问题解决

### Apache无法启动

**原因 :** 协议/地址/端口 其中一个冲突了 , 在报错中可以知道是端口问题 

**解决方案 :** (HTTPS443端口解决)

1. 进入 ==release\softs\Apache\conf\extra\httpd-ahssl.conf==
2. 搜索 `listen` 将 **443** 改为 **442** (改成其他也行)

为了以防万一 80端口也要该下

1. 进入 ==release\softs\Apache\conf\httpd.conf==
2. 搜索 `listen` 将 **80** 改为 **81** (改成其他也行)

**重点 :** 

端口改后需要匹配上对应的端口号才能访问到 Apache服务的站点 , 如 http://www.php8.com:81



