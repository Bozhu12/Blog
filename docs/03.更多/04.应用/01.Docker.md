---
title: Docker
author: 柏竹
permalink: /other/1hg7cc
date: 2020-02-18 00:00:00
categories: 
  - 运维工具
  - 容器技术
  - Docker
tags: 
  - Docker
  - 容器化
  - 运维工具
  - 教程
sidebar: auto
---



# Docker

## 简介

docker是种容器技术，能够解决环境迁移问题 

- 开源应用容器
- 基于Go语言实现
- 轻量级、可移植
- 沙箱机制隔离

**功能**

- 解决代码执行的环境兼容问题
- 软件打包环境直接应用

官网：[https://www.docker.com/](https://www.docker.com/) 

## 安装

### Linux

**安装步骤：** 

1. 安装Docker 
2. 安装组件软件包
3. 配置阿里云镜像加速（自己的

**示例：**

```sh
# 1、yum 包更新到最新
yum update
# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的
yum install -y yum-utils device-mapper-persistent-data lvm2
# 3、 设置yum源
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
# 4、 安装docker，出现输入的界面都按 y
yum install -y docker-ce
# 5、 查看docker版本，验证是否验证成功
docker -v
```

### 镜像加速

镜像加速JSON文件需要手动配置
镜像配置 : [https://developer.aliyun.com/article/110806](https://developer.aliyun.com/article/110806)

**阿里云镜像配置**

1. 登录阿里云 **镜像服务模块** -> **镜像加速** -> 复制操作文档的镜像配置，如：(个人专属镜像加速

   ```json
   {
     "registry-mirrors": ["https://xd43lwzc.mirror.aliyuncs.com"]
   }
   ```

2. 进入路径 ==/etc/docker/daemon.json== (没有则创建

3. 编辑 `daemon.json` 复制添加以上配置

4. 重启 Docker 
   ==systemctl restart docker==

5. 检查配置镜像 。查看参数 ==docker info== (存在以下配置说明配置成功

   ```text
   Registry Mirrors:
   https://xd43lwzc.mirror.aliyuncs.com/
   ```

命令添加镜像源

```sh
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
```

## 命令

官方文档 : [https://docs.docker.com/reference/](https://docs.docker.com/reference/) 

一键查看命令：==docker== 
命令查看详细：==docker <命令前缀> --help== 

### 进程相关

- **启动docker服务**

  ==systemctl start docker== 

- **关闭docker服务**
  
  ==systemctl stop docker== 
  
- **重启docker服务**
  
  ==systemctl restart docker== 
  
- **查看docker状态**
  
  ==systemctl status docker== 
  
- **开机自启docker服务**
  
  ==systemctl enable docker== 

### 镜像相关

- **查看镜像**（查看本地镜像
  
  ==docker images== 查看所有镜像

  ==docker images -q== 查看所有镜像id
  
- **搜索镜像**
  
  ==docker search redis== 查找redis镜像 
  
- **下载镜像** 
  
  ==docker pull redis== 下载最新版本Redis

  ==docker pull redis:5.0== 下载5.0版本Redis
  
  > 如果需要了解指定下载的版本：(搜索版本
  > https://hub.docker.com/
  
- **删除镜像**
  
  ==docker rmi <镜像id>==  删除指定本地镜像
  
  ==docker rmi `docker images -q`== 删除所有镜像
  
- **导入镜像** 

  ==docker load -i <文件名>==

### 容器相关

- **容器查看**
  
  ==docker ps== 查看所有正在运行容器
  
  ==docker ps -a== 查看所有容器
  
  ==docker ps -aq== 查看所有容器id
  
  ==docker port <name/id>== 查看容器端口
  
  ==docker logs -f <name/id>== 查看日志
  
  ==docker logs --tail 300 <name/id>== 查看日志
  
- **查看容器详细**
  
  ==docker inspect <name/id>==
  
- **容器创建**
  
  ==docker run <参数>==
  
  - `-i`：保持容器运行
  - `-t`：为容器分配一个为输入终端
  - `-d`：以守护线程模式运行
  - `--name`：为容器命名
  
  **创建交互式容器**
  创建自动进入容器，退出自动关闭容器
  ==docker run -it --name=c1 redis:5.0 /bin/bash== 
  创建 redis:5.0 镜像且名称为c1的容器，并初始化指令至 /bin/bash 
  
  > 进入容器终端需要手动退出 `exit` 
  
  **创建守护容器**
  容器后台启动需要手动进入
  ==docker run -id --name=c2 mysql /bin/bash== 
  
- **容器进入** 
  
  ==docker exec -it <容器 name/id> /bin/bash== 
  
- **容器退出**
  
  ==exit== / 快捷键==Ctrl+Q+P== 
  
- **容器启动** 
  
  ==docker start <name/id>== 
  
  > 如果是交互式容器，启动后会转变为守护线程
  
- **容器停止**
  
  ==docker stop <name/id>==
  
- **容器删除**
  
  ==docker rm <name/id>== 删除指定容器

  ==docker rm `docker ps -aq`== 删除所有容器
  
  > 如果容器处于运行状态，则需要停止容器才能进行删除
  

## 数据卷

数据源是容器挂载运行的媒介

<img src="https://image.bozhu12.cc/myblog/docker/docker01.png" style="zoom:50%;" />  

**数据卷概念：**

- 数据卷是宿主机中的一个 目录/文件
- 但容器 目录和数据卷 绑定后，会立马同步
- 一个数据卷可同时挂载多个容器
- 一个容器可被多个数据卷挂载

**数据卷作用：**

- 容器数据 持久化
- 外部机器和容器通信的媒介
- 容器之间的数据交互

> PS：容器不能直接与外部机器直接通信，需要依赖宿主机通信交互

### 数据卷配置

创建启动容器时 ，可通过 `-v`参数 设置数据卷

==docker run ... -v <主机目录>:<容器目录> ...==

**注意：**

- 容器目录必须为绝对路径
- 如果目录不存在，会自动创建
- 可以挂载多个数据卷

**示例：**
创建容器 c1 挂载到 宿主机/root/data目录 挂载到 容器/root/data_container目录，并初始化指令 /bin/bash
==docker run -it --name=c1 -v /root/data:/root/data_container mysql /bin/bash==

> 在容器创建的数据会持久化，即便是 停止/删除 容器 文件仍然会存在

**一个容器挂载多个数据卷** 

```dockerfile
docker run -it --name=c2 \
-v ~/data2:/root/data2 \
-v ~/dtaa3:/root/data3 \
mysql /bin/bash
```

> `\`换行作用

**多个容器挂载同一个数据卷** 

```bash
docker run -it --name=c3 -v /root/data:/root/data6 mysql /bin/bash
docker run -it --name=c4 -v /root/data:/root/data6 mysql /bin/bash
```

> 两个容器共享一个数据卷数据访问和修改也会跟随更改（仅限于该数据卷内的数据同步

### 数据卷容器配置

多容器进行数据交互，多个容器挂载在同一数据卷容器，完成数据交互（将容器挂载到同一管理的容器进行同步数据卷

<img src="https://image.bozhu12.cc/myblog/docker/docker02.png" style="zoom:50%;" /> 

> container c3 作为容器同步卷 进行同步 c1 、c2 数据卷

**示例：**

1. 创建启动c3数据卷容器
   ==docker run -it --name=c3 -v /volume mysql /bin/bash==

   > 这里没有指定宿主目录，默认生成目录。查询容器详细：（可得知容器宿主目录
   > ==docker inspect c3== （关注：`Mounts`键集合对象中的 `Source`键 

2. 启动创建c1、c2容器，使用 `--volumes-from`参数 设置数据卷

   ```sh
   docker run -it --name=c1 --volumes-from c3 mysql /bin/bash
   docker run -it --name=c2 --volumes-from c3 mysql /bin/bash
   ```

3. 进入 `/volume`目录 测试同步

> 使用c3数据卷容器创建 c1、c2，如果c3关闭也不影响c1和c2的数据交互

## 应用部署

Docker应用部署容器需要了解一下几点：

- 应用前提都是提前下载镜像再部署应用
- 容器不能直接与外部机器进行通信
- 外部机可以和宿主机进行通信；且宿主机也可和容器通信
- 容器访问外部机需要宿主机调配映射端口与外部机通信

<img src="https://image.bozhu12.cc/myblog/docker/docker03.png" style="zoom:50%;" /> 

> 容器(3306) --- 外部机器(3307)
> 宿主机调配端口映射可以间接的通信

通过官网查找镜像 : https://hub.docker.com/

### MySQL

**部署步骤：**

1. **创建容器目录**

   ```sh
   # 在/root目录下创建mysql目录用于存储mysql数据信息
	mkdir ~/mysql
   cd ~/mysql
   ```
   
2. **创建容器，并设置 端口/目录 映射**

   ```sh
   docker run -id \
   -p 3307:3306 \
   --name=c_mysql \
   -v $PWD/conf:/etc/mysql/conf.d \
   -v $PWD/logs:/logs \
   -v $PWD/data:/var/lib/mysql \
   -e MYSQL_ROOT_PASSWORD=123456 \
   mysql:5.6
   ```

   **参数说明：**

   - **-p 3307:3306**：将 容器3306端口 对应宿主的 3307端口
   - **-v $PWD/conf:/etc/mysql/conf.d**：主机当前/conf目录下创建数据卷 （pwd当前目录路径
   - confg配置目录 / logs日志目录 / data数据目录 
   - **-e MYSQL_ROOT_PASSWORD=123456**：配置参数，初始化root用户密码

3. **进入容器操作**

   ```sh
   # 运行启动容器
	docker exec -it c_mysql /bin/bash
   
   # 进入mysql
	mysql -uroot -p123456
   ```
   
4. **外部连接测试**

   虚拟机IP + 端口3307 即可访问 mysql容器

### Tomcat

**部署步骤：**

1. **创建容器目录**

   ```sh
   # 在/root目录下创建tomcat目录用于存储tomcat数据信息
	mkdir ~/tomcat
   cd ~/tomcat
   ```
   
2. **创建容器，并设置 端口/目录 映射**

   ```sh
   docker run -id --name=c_tomcat \
   -p 8080:8080 \
   -v $PWD:/usr/local/tomcat/webapps \
   tomcat
   ```

   > 参数的详细说明可以参考mysql配置

3. 为容器数据卷 添加页面内容

   ```sh
   mkdir /test
   cd test
   vim index.html

	# 添加H5页面内容保存即可
   ```

4. 外部机访问 IP+端口8080
   ==IP:8080/test/index.html== / ==IP:8080/test/== (Tomcat默认应用index.html

> 应用Web内容时，只需为容器数据卷添加Web内容信息启动容器即可

### Nginx

1. 安装镜像 `nginx`

2. 创建配置文件 (运行docker挂载的配置)

   ```sh
   # 创建挂载目录
   mkdir -p /home/nginx/conf
   mkdir -p /home/nginx/log
   mkdir -p /home/nginx/html
   ```

3. 拷贝主要配置到宿主机

   ```sh
   # 生成容器
	docker run --name nginx -p 9001:80 -d nginx
   
   # 将容器nginx.conf文件复制到宿主机
	docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf
   
   # 将容器conf.d文件夹下内容复制到宿主机
	docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d
   
   # 将容器中的html文件夹复制到宿主机
	docker cp nginx:/usr/share/nginx/html /home/nginx/
   ```
   
4. 运行 Nginx容器

   ```sh
   docker run \
   -p 9002:80 \
   --name nginx \
   -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \
   -v /home/nginx/conf/conf.d:/etc/nginx/conf.d \
   -v /home/nginx/log:/var/log/nginx \
   -v /home/nginx/html:/usr/share/nginx/html \
   -d nginx:latest
   ```

5. 访问 [IP]:9002 即可

| 命令                     | 说明           |
| ------------------------ | -------------- |
| -name [名称]             | 命名           |
| -d                       | 后台运行       |
| -p [宿主端口]:[容器端口] | 端口映射       |
| -v [宿主路径]:[容器路径] | 配置文件挂载   |
| nginx:latest             | 本地运行的版本 |
| \                        | shell 命令换行 |

### RabbitMQ

docker官方 : https://hub.docker.com/_/rabbitmq

**部署步骤：**

1. 官网查找RabbitMQ

2. 建议下载含有Web管理页 , 镜像中带有 `mangement`版本的 , 并拉取下载

3. 启动docker容器  

   ```docker
   docker run -d --name [容器名称]  \
   -p 5672:5672  \
   -p 15672:15672  \
   -v `pwd`/data:/home/rabbitmq  \
   --hostname [节点名称]  \
   -e RABBITMQ_DEFAULT_USER=admin  \
   -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:[tag标签] \
   ```

   我个人的应用方式 (端口小修一下)

   ```docker
   docker run -d --name rabbitmq03  \
   -p 5674:5672  \
   -p 15674:15672  \
   -v `pwd`/data:/home/rabbitmq  \
   --hostname node03  \
   -e RABBITMQ_DEFAULT_USER=admin  \
   -e RABBITMQ_DEFAULT_PASS=admin  \
   rabbitmq:3.11.10-management
   ```

4. 查看界面 ip+15672端口  http://ip:15672/

**选项说明 :** 

| 选项       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| -d         | 后台运行                                                     |
| --name     | 指定容器名称                                                 |
| -p         | 指定端口 [外部端口]:[容器端口] (5672:连接访问; 15672: Web管理页) |
| -v         | 映射 目录/文件                                               |
| --hostname | 主机名 (较为重要 集群作为 **节点名称** 使用)                 |
| -e         | 指定环境变量 (默认账号密码)                                  |

### Redis

**部署步骤：**

1. 下载镜像

2. 创建容器
   ```dockerfile
   docker run -id --name myredis -p 6379:6379 redis
   ```

注意自己的 : 配置路径 , 容器名称 , 端口 , 镜像名称 信息 

**docker连接方式**

```sh
docker run -it --network some-network --rm redis redis-cli -h some-redis
```

## Dockerfile

Dockerfild 是一个用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取`Dockerfile`中的指令自动生成映像

### 镜像原理

镜像原理先从文件管理进行讲述

**Liunx文件管理系统**

Linux文件系统由 **bootfs** 和 **rootfs** 组成
PS：不同发行版本，rootfs也不同，而rootfs基本不变

- bootfs：包含Bootloader(引导加载程序) 和 kernel(内核)
- rootfs：root文件系统，包含有 /dev，/proc，/bin，/etc等

<img src="https://image.bozhu12.cc/myblog/docker/docker04.png" style="zoom:50%;" /> 

**docker镜像文件管理**

<img src="https://image.bozhu12.cc/myblog/docker/docker05.png" style="zoom:50%;" /> 

**Docker镜像原理** 

- Docker镜像有特殊的文件系统叠加而成
- 最低端是 bootfs，并使用宿主机的bootfs，往上则是镜像文件
- 文件系统的统一，将不同的文件层整合一个文件系统，提供统一的视角，隐藏多层的存在，在用户角度来看只有一个文件系统
- 另一往下的镜像称为 **父镜像**，最底层则为 **基础镜像**
- 当启动容器时，Docker会在最顶层加载读取文件作为容器

> 总结：Docker镜像的本质是一个分层的文件系统

**注意：**

- Docker镜像会在不同层级可能会对父产生依赖
- 镜像文件不能以本身决定大小，会复用 父镜像/系统 已有数据

### 镜像制作

#### 文件转镜像

将项目文件打包后(dockerfiler) 转为镜像应用

执行命令

**dockerfiler执行常用指令**

| 命令        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| FROM        | 指定基础镜像                                                 |
| LABEL       | 为镜像指定标签 , 添加镜像元数据 (键值形式)                   |
| MAINTAINER  | 指定维护者信息（已废弃 , 使用LABEL）                         |
| RUN         | 构建过程中 运行命令                                          |
| CMD         | 容器启动时默认执行的命令                                     |
| EXPOSE      | 声明运行时容器监听的端口 (开放端口应用)                      |
| ENV         | 设置环境变量 (容器内部环境变量)                              |
| ADD         | 添加 文件&目录&远程url 到镜像中                              |
| COPY        | 复制 文件&目录 到镜像中                                      |
| ENTRYPOINT  | 配置容器启动后运行的命令                                     |
| VOLUME      | 创建数据卷挂载点                                             |
| USER        | 指定运行容器时的用户名或UID                                  |
| WORKDIR     | 配置工作目录                                                 |
| ARG         | 构建过程中 传递构建器变量，在运行时可以通过--build-arg传递参数 |
| ONBUILD     | 配置当基于当前镜像构建新的镜像时执行的操作 (触发器)          |
| HEALTHCHECK | 定义周期性检查容器健康状态指令                               |

#### 容器转镜像

镜像创建可写容器进行 生成镜像 -> 压缩镜像 -> 应用

**步骤命令解释**

```dockerfile
# 生成镜像
docker commit <容器id> <容器名称>:<版本号> 
# 压缩文件
docker save -o <压缩文件名称.tar> <镜像名称>:<版本号>
# 加载应用镜像
docker load -i <压缩文件>
```

> 容器转镜像 不包括数据卷数据，只封装容器数据

**步骤示例**

```shell
# 数据卷
mkdir ~/c_tomcat
cd ~/c_tomcat
# 创建tomcat镜像
images run -id --name=c_tomcat \
-p 8080:8080 \
-v $PWD:/usr/local/tomcat/webapps \
tomcat
# 进入tomcat镜像
docker exec -it c_tomcat /bin/bash
# 创建a.txt b.txt （该文件用于封装镜像给测试人看的
cd ~
touch a.txt b.txt
# 容器转镜像
docker commit 28b8d4dc9744 lxs_tomcat:1.0
# 压缩镜像
docker save -o lxs_tomcat.tar lxs_tomcat:1.0
#删除 容器/镜像
docker rm c_tomcat
docker rmi lxs_tomcat:1.0
# 从压缩文件加载镜像
docker load -i lxs_tomcat.tar
# 产生镜像
docker run -it --name=new_tomcat lxs_tomcat:1.0 /bin/bash
#进入查看内容
docker exec -it c_tomcat /bin/bash
#可以看到a.txt b.txt存在，而webapps/test不存在
```



## DockerCompone

**安装**

拉去远端

```sh
# 1.27.4 版本
curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose
# 最新版
curl -L "https://github.com/docker/compose/releases/download/v2.36.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
```

授权&测试

```sh
chmod +x /usr/local/bin/docker-compose && docker-compose -version

chmod +x /usr/local/bin/docker-compose && docker compose -version
```



